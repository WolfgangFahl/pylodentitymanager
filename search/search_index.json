{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pylodentitymanager API Documentation","text":""},{"location":"#lodentity.cache","title":"<code>cache</code>","text":"<p>Created on 2024-03-09.</p> <p>@author: wf</p> <p>refactored from https://github.com/WolfgangFahl/pyCEURmake/blob/main/ceurws/utils/json_cache.py by Tim Holzheim</p>"},{"location":"#lodentity.cache.Cache","title":"<code>Cache</code>","text":"<p>Represents cache metadata and its file extension.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the cache.</p> <code>extension</code> <code>str</code> <p>The file extension for the cache (e.g., 'json', 'csv').</p> <code>size</code> <code>int</code> <p>The size of the cache file in bytes.</p> <code>count</code> <code>Optional[int]</code> <p>Optional; the number of items in the cache, if applicable.</p> <code>count_attr</code> <code>str</code> <p>the name of the attribute to determine the number of items, if applicable</p> <code>last_accessed</code> <code>datetime</code> <p>Optional; the last accessed timestamp of the cache.</p> Source code in <code>lodentity/cache.py</code> <pre><code>@lod_storable\nclass Cache:\n    \"\"\"Represents cache metadata and its file extension.\n\n    Attributes:\n        name: The name of the cache.\n        extension: The file extension for the cache (e.g., 'json', 'csv').\n        size: The size of the cache file in bytes.\n        count: Optional; the number of items in the cache, if applicable.\n        count_attr: the name of the attribute to determine the number of items, if applicable\n        last_accessed: Optional; the last accessed timestamp of the cache.\n    \"\"\"\n\n    name: str\n    extension: str\n    count_attr: str = None\n    count: Optional[int] = None\n\n    def set_path(self, base_path: str):\n        \"\"\"Set my path based on the given base_path and ensure the parent\n        directory is created.\n\n        Args:\n            base_path (str): The base path where the directory should be created.\n        \"\"\"\n        self.path = Path(f\"{base_path}/{self.name}{self.extension}\")\n        # Ensure parent directory is created\n        self.path.parent.mkdir(parents=True, exist_ok=True)\n\n    @property\n    def is_stored(self) -&gt; bool:\n        \"\"\"Determines if the cache file exists and is not empty.\"\"\"\n        return self.path.is_file() and self.path.stat().st_size &gt; 1\n\n    @property\n    def size(self) -&gt; int:\n        cache_size = os.path.getsize(self.path) if os.path.isfile(self.path) else 0\n        return cache_size\n\n    @property\n    def last_accessed(self) -&gt; datetime:\n        cache_last_accessed = (\n            datetime.fromtimestamp(os.path.getmtime(self.path))\n            if os.path.isfile(self.path)\n            else None\n        )\n        return cache_last_accessed\n</code></pre>"},{"location":"#lodentity.cache.Cache.is_stored","title":"<code>is_stored</code>  <code>property</code>","text":"<p>Determines if the cache file exists and is not empty.</p>"},{"location":"#lodentity.cache.Cache.set_path","title":"<code>set_path(base_path)</code>","text":"<p>Set my path based on the given base_path and ensure the parent directory is created.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>The base path where the directory should be created.</p> required Source code in <code>lodentity/cache.py</code> <pre><code>def set_path(self, base_path: str):\n    \"\"\"Set my path based on the given base_path and ensure the parent\n    directory is created.\n\n    Args:\n        base_path (str): The base path where the directory should be created.\n    \"\"\"\n    self.path = Path(f\"{base_path}/{self.name}{self.extension}\")\n    # Ensure parent directory is created\n    self.path.parent.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"#lodentity.cache.CacheManager","title":"<code>CacheManager</code>","text":"<p>Manages multiple cache files with various extensions.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name used for the base directory where cache files are stored.</p> <code>caches</code> <code>Dict[str, Cache]</code> <p>A dictionary to track each cache's metadata.</p> Source code in <code>lodentity/cache.py</code> <pre><code>@lod_storable\nclass CacheManager:\n    \"\"\"Manages multiple cache files with various extensions.\n\n    Attributes:\n        name: The name used for the base directory where cache files are stored.\n        caches: A dictionary to track each cache's metadata.\n    \"\"\"\n\n    name: str\n    caches: Dict[str, Cache] = field(default_factory=dict)\n\n    def __post_init__(self):\n        self.base_dir = None\n\n    def base_path(self) -&gt; str:\n        \"\"\"Fetches the base path for this cache manager.\n\n        Args:\n            cache: The cache for which to generate the file path.\n\n        Returns:\n            The base path\n        \"\"\"\n        if self.base_dir is None:\n            self.base_dir = os.path.expanduser(\"~\")\n        base_path = os.path.join(self.base_dir, f\".{self.name}\")\n        os.makedirs(base_path, exist_ok=True)\n        return base_path\n\n    def get_cache_by_name(self, lod_name, ext=\".json\") -&gt; Cache:\n        \"\"\"Retrieves or creates a cache object by name and extension.\n\n        Args:\n            cache_name (str): The name of the cache to retrieve or create.\n            ext (str): The file extension for the cache.\n\n        Returns:\n            Cache: An existing or newly created Cache object.\n        \"\"\"\n        if lod_name in self.caches:\n            cache = self.caches[lod_name + ext]\n        else:\n            cache = Cache(lod_name, ext)\n            self.caches[lod_name + ext] = cache\n        base_path = self.base_path()\n        cache.set_path(base_path)\n        return cache\n\n    def load(\n        self,\n        lod_name: str,\n        ext: str = \".json\",\n        cls: Optional[Type[YamlAble]] = None,\n        count_attr: str = None,\n    ) -&gt; Union[List, Dict, None]:\n        \"\"\"Load data from a cache file. This method supports JSON and, if a\n        relevant class is provided, other formats like YAML.\n\n        Args:\n            lod_name (str): The name of the list of dicts or class instances to read from cache.\n            ext (str): The extension of the cache file, indicating the format (default is \".json\").\n            cls (Optional[Type[YamlAble]]): The class type for deserialization. This class must have from_json() or from_yaml()\n                                             class methods for deserialization, depending on the file extension.\n            count_attr(str): the name of attribute data_to_store for updating the cache.count s\n        Returns:\n            Union[List, Dict, None]: A list of dicts, a list of class instances, a single dict, or None if the cache is not stored.\n        \"\"\"\n        cache = self.get_cache_by_name(lod_name, ext)\n        cache.count_attr = count_attr\n        result = None\n        if cache.is_stored:\n            if ext == \".json\":\n                if cls and hasattr(cls, \"load_from_yaml_file\"):\n                    result = cls.load_from_json_file(\n                        cache.path\n                    )  # Adjusted for class method\n                else:\n                    with open(cache.path, encoding=\"utf-8\") as json_file:\n                        result = orjson.loads(json_file.read())\n            elif ext == \".yaml\":\n                if cls and hasattr(cls, \"load_from_yaml_file\"):\n                    result = cls.load_from_yaml_file(\n                        cache.path\n                    )  # Adjusted for class method\n                else:\n                    raise ValueError(\n                        \"YAML deserialization requires a cls parameter that is a subclass of YamlAble.\"\n                    )\n            else:\n                raise ValueError(f\"Unsupported file extension {ext} for loading.\")\n\n            # Dynamic count update based on count_attr if applicable\n            if count_attr and hasattr(result, count_attr):\n                cache.count = len(getattr(result, count_attr))\n            elif isinstance(result, list):\n                cache.count = len(result)\n\n        return result\n\n    def store(\n        self,\n        cache_name: str,\n        data_to_store: Union[List, Dict],\n        ext: str = \".json\",\n        count_attr: str = None,\n    ) -&gt; Cache:\n        \"\"\"Stores data into a cache file, handling serialization based on the\n        specified file extension. Supports JSON and YAML formats, and custom\n        serialization for classes that provide specific serialization methods.\n\n        Args:\n            cache_name (str): The identifier for the cache where the data will be stored.\n            data_to_store (Union[List, Dict]): The data to be stored in the cache. This can be a list of dictionaries,\n                                               a single dictionary, or instances of data classes if `cls` is provided.\n            ext (str): The file extension indicating the serialization format (e.g., '.json', '.yaml').\n                       Defaults to '.json'.\n            count_attr(str): the name of attribute data_to_store for updating the cache.count s\n\n        Raises:\n            ValueError: If the file extension is unsupported or if required methods for serialization are not implemented in `cls`.\n        \"\"\"\n        cache = self.get_cache_by_name(cache_name, ext)\n        cache.count_attr = count_attr\n        cache.set_path(self.base_path())\n\n        if ext == \".json\":\n            # Check if  cls has a method `save_to_json_file`\n            # that accepts a file path and data to store\n            if isinstance(data_to_store, list):\n                json_str = orjson.dumps(data_to_store, option=orjson.OPT_INDENT_2)\n                with cache.path.open(\"wb\") as json_file:\n                    json_file.write(json_str)\n            else:\n                if hasattr(data_to_store, \"save_to_json_file\"):\n                    data_to_store.save_to_json_file(str(cache.path))\n                else:\n                    raise ValueError(\n                        \"JSON serialization requires a 'save_to_json_file' method\"\n                    )\n        elif ext == \".yaml\":\n            if hasattr(data_to_store, \"save_to_yaml_file\"):\n                # Assuming cls has a method `save_to_yaml_file` that accepts a file path and data to store\n                data_to_store.save_to_yaml_file(str(cache.path))\n            else:\n                raise ValueError(\n                    \"YAML serialization requires a 'save_to_yaml_file' method.\"\n                )\n        else:\n            raise ValueError(f\"Unsupported file extension {ext}.\")\n\n        # Update cache metadata post storing\n        if count_attr and hasattr(data_to_store, count_attr):\n            cache.count = len(getattr(data_to_store, count_attr))\n        elif isinstance(data_to_store, list):\n            cache.count = len(data_to_store)\n\n        return cache\n</code></pre>"},{"location":"#lodentity.cache.CacheManager.base_path","title":"<code>base_path()</code>","text":"<p>Fetches the base path for this cache manager.</p> <p>Parameters:</p> Name Type Description Default <code>cache</code> <p>The cache for which to generate the file path.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The base path</p> Source code in <code>lodentity/cache.py</code> <pre><code>def base_path(self) -&gt; str:\n    \"\"\"Fetches the base path for this cache manager.\n\n    Args:\n        cache: The cache for which to generate the file path.\n\n    Returns:\n        The base path\n    \"\"\"\n    if self.base_dir is None:\n        self.base_dir = os.path.expanduser(\"~\")\n    base_path = os.path.join(self.base_dir, f\".{self.name}\")\n    os.makedirs(base_path, exist_ok=True)\n    return base_path\n</code></pre>"},{"location":"#lodentity.cache.CacheManager.get_cache_by_name","title":"<code>get_cache_by_name(lod_name, ext='.json')</code>","text":"<p>Retrieves or creates a cache object by name and extension.</p> <p>Parameters:</p> Name Type Description Default <code>cache_name</code> <code>str</code> <p>The name of the cache to retrieve or create.</p> required <code>ext</code> <code>str</code> <p>The file extension for the cache.</p> <code>'.json'</code> <p>Returns:</p> Name Type Description <code>Cache</code> <code>Cache</code> <p>An existing or newly created Cache object.</p> Source code in <code>lodentity/cache.py</code> <pre><code>def get_cache_by_name(self, lod_name, ext=\".json\") -&gt; Cache:\n    \"\"\"Retrieves or creates a cache object by name and extension.\n\n    Args:\n        cache_name (str): The name of the cache to retrieve or create.\n        ext (str): The file extension for the cache.\n\n    Returns:\n        Cache: An existing or newly created Cache object.\n    \"\"\"\n    if lod_name in self.caches:\n        cache = self.caches[lod_name + ext]\n    else:\n        cache = Cache(lod_name, ext)\n        self.caches[lod_name + ext] = cache\n    base_path = self.base_path()\n    cache.set_path(base_path)\n    return cache\n</code></pre>"},{"location":"#lodentity.cache.CacheManager.load","title":"<code>load(lod_name, ext='.json', cls=None, count_attr=None)</code>","text":"<p>Load data from a cache file. This method supports JSON and, if a relevant class is provided, other formats like YAML.</p> <p>Parameters:</p> Name Type Description Default <code>lod_name</code> <code>str</code> <p>The name of the list of dicts or class instances to read from cache.</p> required <code>ext</code> <code>str</code> <p>The extension of the cache file, indicating the format (default is \".json\").</p> <code>'.json'</code> <code>cls</code> <code>Optional[Type[YamlAble]]</code> <p>The class type for deserialization. This class must have from_json() or from_yaml()                              class methods for deserialization, depending on the file extension.</p> <code>None</code> <code>count_attr(str)</code> <p>the name of attribute data_to_store for updating the cache.count s</p> required <p>Returns:     Union[List, Dict, None]: A list of dicts, a list of class instances, a single dict, or None if the cache is not stored.</p> Source code in <code>lodentity/cache.py</code> <pre><code>def load(\n    self,\n    lod_name: str,\n    ext: str = \".json\",\n    cls: Optional[Type[YamlAble]] = None,\n    count_attr: str = None,\n) -&gt; Union[List, Dict, None]:\n    \"\"\"Load data from a cache file. This method supports JSON and, if a\n    relevant class is provided, other formats like YAML.\n\n    Args:\n        lod_name (str): The name of the list of dicts or class instances to read from cache.\n        ext (str): The extension of the cache file, indicating the format (default is \".json\").\n        cls (Optional[Type[YamlAble]]): The class type for deserialization. This class must have from_json() or from_yaml()\n                                         class methods for deserialization, depending on the file extension.\n        count_attr(str): the name of attribute data_to_store for updating the cache.count s\n    Returns:\n        Union[List, Dict, None]: A list of dicts, a list of class instances, a single dict, or None if the cache is not stored.\n    \"\"\"\n    cache = self.get_cache_by_name(lod_name, ext)\n    cache.count_attr = count_attr\n    result = None\n    if cache.is_stored:\n        if ext == \".json\":\n            if cls and hasattr(cls, \"load_from_yaml_file\"):\n                result = cls.load_from_json_file(\n                    cache.path\n                )  # Adjusted for class method\n            else:\n                with open(cache.path, encoding=\"utf-8\") as json_file:\n                    result = orjson.loads(json_file.read())\n        elif ext == \".yaml\":\n            if cls and hasattr(cls, \"load_from_yaml_file\"):\n                result = cls.load_from_yaml_file(\n                    cache.path\n                )  # Adjusted for class method\n            else:\n                raise ValueError(\n                    \"YAML deserialization requires a cls parameter that is a subclass of YamlAble.\"\n                )\n        else:\n            raise ValueError(f\"Unsupported file extension {ext} for loading.\")\n\n        # Dynamic count update based on count_attr if applicable\n        if count_attr and hasattr(result, count_attr):\n            cache.count = len(getattr(result, count_attr))\n        elif isinstance(result, list):\n            cache.count = len(result)\n\n    return result\n</code></pre>"},{"location":"#lodentity.cache.CacheManager.store","title":"<code>store(cache_name, data_to_store, ext='.json', count_attr=None)</code>","text":"<p>Stores data into a cache file, handling serialization based on the specified file extension. Supports JSON and YAML formats, and custom serialization for classes that provide specific serialization methods.</p> <p>Parameters:</p> Name Type Description Default <code>cache_name</code> <code>str</code> <p>The identifier for the cache where the data will be stored.</p> required <code>data_to_store</code> <code>Union[List, Dict]</code> <p>The data to be stored in the cache. This can be a list of dictionaries,                                a single dictionary, or instances of data classes if <code>cls</code> is provided.</p> required <code>ext</code> <code>str</code> <p>The file extension indicating the serialization format (e.g., '.json', '.yaml').        Defaults to '.json'.</p> <code>'.json'</code> <code>count_attr(str)</code> <p>the name of attribute data_to_store for updating the cache.count s</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file extension is unsupported or if required methods for serialization are not implemented in <code>cls</code>.</p> Source code in <code>lodentity/cache.py</code> <pre><code>def store(\n    self,\n    cache_name: str,\n    data_to_store: Union[List, Dict],\n    ext: str = \".json\",\n    count_attr: str = None,\n) -&gt; Cache:\n    \"\"\"Stores data into a cache file, handling serialization based on the\n    specified file extension. Supports JSON and YAML formats, and custom\n    serialization for classes that provide specific serialization methods.\n\n    Args:\n        cache_name (str): The identifier for the cache where the data will be stored.\n        data_to_store (Union[List, Dict]): The data to be stored in the cache. This can be a list of dictionaries,\n                                           a single dictionary, or instances of data classes if `cls` is provided.\n        ext (str): The file extension indicating the serialization format (e.g., '.json', '.yaml').\n                   Defaults to '.json'.\n        count_attr(str): the name of attribute data_to_store for updating the cache.count s\n\n    Raises:\n        ValueError: If the file extension is unsupported or if required methods for serialization are not implemented in `cls`.\n    \"\"\"\n    cache = self.get_cache_by_name(cache_name, ext)\n    cache.count_attr = count_attr\n    cache.set_path(self.base_path())\n\n    if ext == \".json\":\n        # Check if  cls has a method `save_to_json_file`\n        # that accepts a file path and data to store\n        if isinstance(data_to_store, list):\n            json_str = orjson.dumps(data_to_store, option=orjson.OPT_INDENT_2)\n            with cache.path.open(\"wb\") as json_file:\n                json_file.write(json_str)\n        else:\n            if hasattr(data_to_store, \"save_to_json_file\"):\n                data_to_store.save_to_json_file(str(cache.path))\n            else:\n                raise ValueError(\n                    \"JSON serialization requires a 'save_to_json_file' method\"\n                )\n    elif ext == \".yaml\":\n        if hasattr(data_to_store, \"save_to_yaml_file\"):\n            # Assuming cls has a method `save_to_yaml_file` that accepts a file path and data to store\n            data_to_store.save_to_yaml_file(str(cache.path))\n        else:\n            raise ValueError(\n                \"YAML serialization requires a 'save_to_yaml_file' method.\"\n            )\n    else:\n        raise ValueError(f\"Unsupported file extension {ext}.\")\n\n    # Update cache metadata post storing\n    if count_attr and hasattr(data_to_store, count_attr):\n        cache.count = len(getattr(data_to_store, count_attr))\n    elif isinstance(data_to_store, list):\n        cache.count = len(data_to_store)\n\n    return cache\n</code></pre>"},{"location":"#lodentity.entity","title":"<code>entity</code>","text":"<p>Created on 2020-08-19.</p> <p>@author: wf</p>"},{"location":"#lodentity.entity.EntityManager","title":"<code>EntityManager</code>","text":"<p>Generic entity manager.</p> Source code in <code>lodentity/entity.py</code> <pre><code>class EntityManager:\n    \"\"\"Generic entity manager.\"\"\"\n\n    def __init__(\n        self,\n        name,\n        entityName,\n        entityPluralName: str,\n        listName: str = None,\n        clazz=None,\n        tableName: str = None,\n        primaryKey: str = None,\n        config=None,\n        handleInvalidListTypes=False,\n        filterInvalidListTypes=False,\n        listSeparator=\"\u21f9\",\n        debug=False,\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            name(string): name of this eventManager\n            entityName(string): entityType to be managed e.g. Country\n            entityPluralName(string): plural of the the entityType e.g. Countries\n            config(StorageConfig): the configuration to be used if None a default configuration will be used\n            handleInvalidListTypes(bool): True if invalidListTypes should be converted or filtered\n            filterInvalidListTypes(bool): True if invalidListTypes should be deleted\n            listSeparator(str): the symbol to use as a list separator\n            debug(boolean): override debug setting when default of config is used via config=None\n        \"\"\"\n        self.name = name\n        self.entityName = entityName\n        self.entityPluralName = entityPluralName\n        if listName is None:\n            listName = entityPluralName\n        if tableName is None:\n            tableName = entityName\n        self.primaryKey = primaryKey\n        if config is None:\n            config = StorageConfig.getDefault()\n            if debug:\n                config.debug = debug\n        self.config = config\n        super(EntityManager, self).__init__(\n            listName=listName,\n            clazz=clazz,\n            tableName=tableName,\n            handleInvalidListTypes=handleInvalidListTypes,\n            filterInvalidListTypes=filterInvalidListTypes,\n        )\n        cacheFile = self.getCacheFile(config=config, mode=config.mode)\n        self.showProgress(\n            \"Creating %smanager(%s) for %s using cache %s\"\n            % (self.entityName, config.mode, self.name, cacheFile)\n        )\n        if config.mode is StoreMode.SPARQL:\n            if config.endpoint is None:\n                raise Exception(\"no endpoint set for mode sparql\")\n            self.endpoint = config.endpoint\n            self.sparql = SPARQL(\n                config.endpoint, debug=config.debug, profile=config.profile\n            )\n        elif config.mode is StoreMode.SQL:\n            self.executeMany = False  # may be True when issues are fixed\n        self.listSeparator = listSeparator\n\n    def storeMode(self):\n        \"\"\"Return my store mode.\"\"\"\n        return self.config.mode\n\n    def showProgress(self, msg):\n        \"\"\"Display a progress message.\n\n        Args:\n          msg(string): the message to display\n        \"\"\"\n        if self.config.withShowProgress:\n            print(msg, flush=True)\n\n    def getCacheFile(self, config=None, mode=StoreMode.SQL):\n        \"\"\"\n        get the cache file for this event manager\n        Args:\n            config(StorageConfig): if None get the cache for my mode\n            mode(StoreMode): the storeMode to use\n        \"\"\"\n        if config is None:\n            config = self.config\n        cachedir = config.getCachePath()\n        if config.cacheFile is not None:\n            return config.cacheFile\n        \"\"\" get the path to the file for my cached data \"\"\"\n        if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n            extension = f\".{mode.name.lower()}\"\n            cachepath = f\"{cachedir}/{self.name}-{self.listName}{extension}\"\n        elif mode is StoreMode.SPARQL:\n            cachepath = f\"SPAQRL {self.name}:{config.endpoint}\"\n        elif mode is StoreMode.SQL:\n            cachepath = f\"{cachedir}/{self.name}.db\"\n        else:\n            cachepath = f\"undefined cachepath for StoreMode {mode}\"\n        return cachepath\n\n    def removeCacheFile(self):\n        \"\"\"Remove my cache file.\"\"\"\n        mode = self.config.mode\n        if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n            cacheFile = self.getCacheFile(mode=mode)\n            if os.path.isfile(cacheFile):\n                os.remove(cacheFile)\n\n    def getSQLDB(self, cacheFile):\n        \"\"\"Get the SQL database for the given cacheFile.\n\n        Args:\n            cacheFile(string): the file to get the SQL db from\n        \"\"\"\n        config = self.config\n        sqldb = self.sqldb = SQLDB(\n            cacheFile, debug=config.debug, errorDebug=config.errorDebug\n        )\n        return sqldb\n\n    def initSQLDB(\n        self,\n        sqldb,\n        listOfDicts=None,\n        withCreate: bool = True,\n        withDrop: bool = True,\n        sampleRecordCount=-1,\n    ):\n        \"\"\"Initialize my sql DB.\n\n        Args:\n            listOfDicts(list): the list of dicts to analyze for type information\n            withDrop(boolean): true if the existing Table should be dropped\n            withCreate(boolean): true if the create Table command should be executed - false if only the entityInfo should be returned\n            sampleRecordCount(int): the number of records to analyze for type information\n        Return:\n            EntityInfo: the entity information such as CREATE Table command\n        \"\"\"\n        if listOfDicts is None:\n            listOfDicts = JSONAble.getJsonTypeSamplesForClass(self.clazz)\n        entityInfo = sqldb.createTable(\n            listOfDicts,\n            self.tableName,\n            primaryKey=self.primaryKey,\n            withCreate=withCreate,\n            withDrop=withDrop,\n            sampleRecordCount=sampleRecordCount,\n        )\n        return entityInfo\n\n    def setNone(self, record, fields):\n        \"\"\"\n        make sure the given fields in the given record are set to none\n        Args:\n            record(dict): the record to work on\n            fields(list): the list of fields to set to None\n        \"\"\"\n        LOD.setNone(record, fields)\n\n    def isCached(self):\n        \"\"\"Check whether there is a file containing cached data for me.\"\"\"\n        result = False\n        config = self.config\n        mode = self.config.mode\n        if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n            result = os.path.isfile(self.getCacheFile(config=self.config, mode=mode))\n        elif mode is StoreMode.SPARQL:\n            # @FIXME - make abstract\n            query = (\n                config.prefix\n                + \"\"\"\nSELECT  ?source (COUNT(?source) AS ?sourcecount)\nWHERE {\n   ?event cr:Event_source ?source.\n}\nGROUP by ?source\n\"\"\"\n            )\n            sourceCountList = self.sparql.queryAsListOfDicts(query)\n            for sourceCount in sourceCountList:\n                source = sourceCount[\"source\"]\n                recordCount = sourceCount[\"sourcecount\"]\n                if source == self.name and recordCount &gt; 100:\n                    result = True\n        elif mode is StoreMode.SQL:\n            cacheFile = self.getCacheFile(config=self.config, mode=StoreMode.SQL)\n            if os.path.isfile(cacheFile):\n                sqlQuery = f\"SELECT COUNT(*) AS count FROM {self.tableName}\"\n                try:\n                    sqlDB = self.getSQLDB(cacheFile)\n                    countResults = sqlDB.query(sqlQuery)\n                    countResult = countResults[0]\n                    count = countResult[\"count\"]\n                    result = count &gt;= 0\n                except Exception as ex:\n                    msg = str(ex)\n                    if self.debug:\n                        print(msg, file=sys.stderr)\n                        sys.stderr.flush()\n                    # e.g. sqlite3.OperationalError: no such table: Event_crossref\n                    pass\n        else:\n            raise Exception(\"unsupported mode %s\" % self.mode)\n        return result\n\n    def fromCache(\n        self,\n        force: bool = False,\n        getListOfDicts=None,\n        append=False,\n        sampleRecordCount=-1,\n    ):\n        \"\"\"Get my entries from the cache or from the callback provided.\n\n        Args:\n            force(bool): force ignoring the cache\n            getListOfDicts(callable): a function to call for getting the data\n            append(bool): True if records should be appended\n            sampleRecordCount(int): the number of records to analyze for type information\n\n        Returns:\n            the list of Dicts and as a side effect setting self.cacheFile\n        \"\"\"\n        if not self.isCached() or force:\n            startTime = time.time()\n            self.showProgress(f\"getting {self.entityPluralName} for {self.name} ...\")\n            if getListOfDicts is None:\n                if hasattr(self, \"getListOfDicts\"):\n                    getListOfDicts = self.getListOfDicts\n                else:\n                    raise Exception(\n                        \"from Cache failed and no secondary cache via getListOfDicts specified\"\n                    )\n            listOfDicts = getListOfDicts()\n            duration = time.time() - startTime\n            self.showProgress(\n                f\"got {len(listOfDicts)} {self.entityPluralName} in {duration:5.1f} s\"\n            )\n            self.cacheFile = self.storeLoD(\n                listOfDicts, append=append, sampleRecordCount=sampleRecordCount\n            )\n            self.setListFromLoD(listOfDicts)\n        else:\n            # fromStore also sets self.cacheFile\n            listOfDicts = self.fromStore()\n        return listOfDicts\n\n    def fromStore(self, cacheFile=None, setList: bool = True) -&gt; list:\n        \"\"\"\n        restore me from the store\n        Args:\n            cacheFile(String): the cacheFile to use if None use the pre configured cachefile\n            setList(bool): if True set my list with the data from the cache file\n\n        Returns:\n            list: list of dicts or JSON entitymanager\n        \"\"\"\n        startTime = time.time()\n        if cacheFile is None:\n            cacheFile = self.getCacheFile(config=self.config, mode=self.config.mode)\n        self.cacheFile = cacheFile\n        self.showProgress(\n            \"reading %s for %s from cache %s\"\n            % (self.entityPluralName, self.name, cacheFile)\n        )\n        mode = self.config.mode\n        if mode is StoreMode.JSONPICKLE:\n            JSONem = JsonPickleMixin.readJsonPickle(cacheFile)\n            if self.clazz is not None:\n                listOfDicts = JSONem.getLoD()\n            else:\n                listOfDicts = JSONem.getList()\n        elif mode is StoreMode.JSON:\n            listOfDicts = self.readLodFromJsonFile(cacheFile)\n            pass\n        elif mode is StoreMode.SPARQL:\n            # @FIXME make abstract\n            eventQuery = (\n                \"\"\"\nPREFIX cr: &lt;http://cr.bitplan.com/&gt;\nSELECT ?eventId ?acronym ?series ?title ?year ?country ?city ?startDate ?endDate ?url ?source WHERE {\n   OPTIONAL { ?event cr:Event_eventId ?eventId. }\n   OPTIONAL { ?event cr:Event_acronym ?acronym. }\n   OPTIONAL { ?event cr:Event_series ?series. }\n   OPTIONAL { ?event cr:Event_title ?title. }\n   OPTIONAL { ?event cr:Event_year ?year.  }\n   OPTIONAL { ?event cr:Event_country ?country. }\n   OPTIONAL { ?event cr:Event_city ?city. }\n   OPTIONAL { ?event cr:Event_startDate ?startDate. }\n   OPTIONAL { ?event cr:Event_endDate ?endDate. }\n   OPTIONAL { ?event cr:Event_url ?url. }\n   ?event cr:Event_source ?source FILTER(?source='%s').\n}\n\"\"\"\n                % self.name\n            )\n            listOfDicts = self.sparql.queryAsListOfDicts(eventQuery)\n        elif mode is StoreMode.SQL:\n            sqlQuery = \"SELECT * FROM %s\" % self.tableName\n            sqlDB = self.getSQLDB(cacheFile)\n            listOfDicts = sqlDB.query(sqlQuery)\n            sqlDB.close()\n            pass\n        else:\n            raise Exception(\"unsupported store mode %s\" % self.mode)\n\n        self.showProgress(\n            \"read %d %s from %s in %5.1f s\"\n            % (\n                len(listOfDicts),\n                self.entityPluralName,\n                self.name,\n                time.time() - startTime,\n            )\n        )\n        if setList:\n            self.setListFromLoD(listOfDicts)\n        return listOfDicts\n\n    def getLoD(self):\n        \"\"\"Return the LoD of the entities in the list.\n\n        Return:\n            list: a list of Dicts\n        \"\"\"\n        lod = []\n        for entity in self.getList():\n            # TODO - optionally filter by samples\n            lod.append(entity.__dict__)\n        return lod\n\n    def store(\n        self,\n        limit=10000000,\n        batchSize=250,\n        append=False,\n        fixNone=True,\n        sampleRecordCount=-1,\n        replace: bool = False,\n    ) -&gt; str:\n        \"\"\"Store my list of dicts.\n\n        Args:\n            limit(int): maximum number of records to store per batch\n            batchSize(int): size of batch for storing\n            append(bool): True if records should be appended\n            fixNone(bool): if True make sure the dicts are filled with None references for each record\n            sampleRecordCount(int): the number of records to analyze for type information\n            replace(bool): if True allow replace for insert\n\n        Return:\n            str: The cachefile being used\n        \"\"\"\n        lod = self.getLoD()\n        return self.storeLoD(\n            lod,\n            limit=limit,\n            batchSize=batchSize,\n            append=append,\n            fixNone=fixNone,\n            sampleRecordCount=sampleRecordCount,\n            replace=replace,\n        )\n\n    def storeLoD(\n        self,\n        listOfDicts,\n        limit=10000000,\n        batchSize=250,\n        cacheFile=None,\n        append=False,\n        fixNone=True,\n        sampleRecordCount=1,\n        replace: bool = False,\n    ) -&gt; str:\n        \"\"\"Store my entities.\n\n        Args:\n            listOfDicts(list): the list of dicts to store\n            limit(int): maximum number of records to store\n            batchSize(int): size of batch for storing\n            cacheFile(string): the name of the storage e.g path to JSON or sqlite3 file\n            append(bool): True if records should be appended\n            fixNone(bool): if True make sure the dicts are filled with None references for each record\n            sampleRecordCount(int): the number of records to analyze for type information\n            replace(bool): if True allow replace for insert\n        Return:\n            str: The cachefile being used\n        \"\"\"\n        config = self.config\n        mode = config.mode\n        if self.handleInvalidListTypes:\n            LOD.handleListTypes(\n                lod=listOfDicts,\n                doFilter=self.filterInvalidListTypes,\n                separator=self.listSeparator,\n            )\n        if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n            if cacheFile is None:\n                cacheFile = self.getCacheFile(config=self.config, mode=mode)\n            self.showProgress(\n                f\"storing {len(listOfDicts)} {self.entityPluralName} for {self.name} to cache {cacheFile}\"\n            )\n            if mode is StoreMode.JSONPICKLE:\n                self.writeJsonPickle(cacheFile)\n            if mode is StoreMode.JSON:\n                self.storeToJsonFile(cacheFile)\n                pass\n        elif mode is StoreMode.SPARQL:\n            startTime = time.time()\n            msg = f\"storing {len(listOfDicts)} {self.entityPluralName} to {self.config.mode} ({self.config.endpoint})\"\n            self.showProgress(msg)\n            # @ FIXME make abstract /configurable\n            entityType = \"cr:Event\"\n            prefixes = self.config.prefix\n            self.sparql.insertListOfDicts(\n                listOfDicts,\n                entityType,\n                self.primaryKey,\n                prefixes,\n                limit=limit,\n                batchSize=batchSize,\n            )\n            self.showProgress(\n                \"store for %s done after %5.1f secs\"\n                % (self.name, time.time() - startTime)\n            )\n        elif mode is StoreMode.SQL:\n            startTime = time.time()\n            if cacheFile is None:\n                cacheFile = self.getCacheFile(config=self.config, mode=self.config.mode)\n            sqldb = self.getSQLDB(cacheFile)\n            self.showProgress(\n                \"storing %d %s for %s to %s:%s\"\n                % (\n                    len(listOfDicts),\n                    self.entityPluralName,\n                    self.name,\n                    config.mode,\n                    cacheFile,\n                )\n            )\n            if append:\n                withDrop = False\n                withCreate = False\n            else:\n                withDrop = True\n                withCreate = True\n            entityInfo = self.initSQLDB(\n                sqldb,\n                listOfDicts,\n                withCreate=withCreate,\n                withDrop=withDrop,\n                sampleRecordCount=sampleRecordCount,\n            )\n            self.sqldb.store(\n                listOfDicts,\n                entityInfo,\n                executeMany=self.executeMany,\n                fixNone=fixNone,\n                replace=replace,\n            )\n            self.showProgress(\n                \"store for %s done after %5.1f secs\"\n                % (self.name, time.time() - startTime)\n            )\n        else:\n            raise Exception(f\"unsupported store mode {self.mode}\")\n        return cacheFile\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.__init__","title":"<code>__init__(name, entityName, entityPluralName, listName=None, clazz=None, tableName=None, primaryKey=None, config=None, handleInvalidListTypes=False, filterInvalidListTypes=False, listSeparator='\u21f9', debug=False)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name(string)</code> <p>name of this eventManager</p> required <code>entityName(string)</code> <p>entityType to be managed e.g. Country</p> required <code>entityPluralName(string)</code> <p>plural of the the entityType e.g. Countries</p> required <code>config(StorageConfig)</code> <p>the configuration to be used if None a default configuration will be used</p> required <code>handleInvalidListTypes(bool)</code> <p>True if invalidListTypes should be converted or filtered</p> required <code>filterInvalidListTypes(bool)</code> <p>True if invalidListTypes should be deleted</p> required <code>listSeparator(str)</code> <p>the symbol to use as a list separator</p> required <code>debug(boolean)</code> <p>override debug setting when default of config is used via config=None</p> required Source code in <code>lodentity/entity.py</code> <pre><code>def __init__(\n    self,\n    name,\n    entityName,\n    entityPluralName: str,\n    listName: str = None,\n    clazz=None,\n    tableName: str = None,\n    primaryKey: str = None,\n    config=None,\n    handleInvalidListTypes=False,\n    filterInvalidListTypes=False,\n    listSeparator=\"\u21f9\",\n    debug=False,\n):\n    \"\"\"Constructor.\n\n    Args:\n        name(string): name of this eventManager\n        entityName(string): entityType to be managed e.g. Country\n        entityPluralName(string): plural of the the entityType e.g. Countries\n        config(StorageConfig): the configuration to be used if None a default configuration will be used\n        handleInvalidListTypes(bool): True if invalidListTypes should be converted or filtered\n        filterInvalidListTypes(bool): True if invalidListTypes should be deleted\n        listSeparator(str): the symbol to use as a list separator\n        debug(boolean): override debug setting when default of config is used via config=None\n    \"\"\"\n    self.name = name\n    self.entityName = entityName\n    self.entityPluralName = entityPluralName\n    if listName is None:\n        listName = entityPluralName\n    if tableName is None:\n        tableName = entityName\n    self.primaryKey = primaryKey\n    if config is None:\n        config = StorageConfig.getDefault()\n        if debug:\n            config.debug = debug\n    self.config = config\n    super(EntityManager, self).__init__(\n        listName=listName,\n        clazz=clazz,\n        tableName=tableName,\n        handleInvalidListTypes=handleInvalidListTypes,\n        filterInvalidListTypes=filterInvalidListTypes,\n    )\n    cacheFile = self.getCacheFile(config=config, mode=config.mode)\n    self.showProgress(\n        \"Creating %smanager(%s) for %s using cache %s\"\n        % (self.entityName, config.mode, self.name, cacheFile)\n    )\n    if config.mode is StoreMode.SPARQL:\n        if config.endpoint is None:\n            raise Exception(\"no endpoint set for mode sparql\")\n        self.endpoint = config.endpoint\n        self.sparql = SPARQL(\n            config.endpoint, debug=config.debug, profile=config.profile\n        )\n    elif config.mode is StoreMode.SQL:\n        self.executeMany = False  # may be True when issues are fixed\n    self.listSeparator = listSeparator\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.fromCache","title":"<code>fromCache(force=False, getListOfDicts=None, append=False, sampleRecordCount=-1)</code>","text":"<p>Get my entries from the cache or from the callback provided.</p> <p>Parameters:</p> Name Type Description Default <code>force(bool)</code> <p>force ignoring the cache</p> required <code>getListOfDicts(callable)</code> <p>a function to call for getting the data</p> required <code>append(bool)</code> <p>True if records should be appended</p> required <code>sampleRecordCount(int)</code> <p>the number of records to analyze for type information</p> required <p>Returns:</p> Type Description <p>the list of Dicts and as a side effect setting self.cacheFile</p> Source code in <code>lodentity/entity.py</code> <pre><code>def fromCache(\n    self,\n    force: bool = False,\n    getListOfDicts=None,\n    append=False,\n    sampleRecordCount=-1,\n):\n    \"\"\"Get my entries from the cache or from the callback provided.\n\n    Args:\n        force(bool): force ignoring the cache\n        getListOfDicts(callable): a function to call for getting the data\n        append(bool): True if records should be appended\n        sampleRecordCount(int): the number of records to analyze for type information\n\n    Returns:\n        the list of Dicts and as a side effect setting self.cacheFile\n    \"\"\"\n    if not self.isCached() or force:\n        startTime = time.time()\n        self.showProgress(f\"getting {self.entityPluralName} for {self.name} ...\")\n        if getListOfDicts is None:\n            if hasattr(self, \"getListOfDicts\"):\n                getListOfDicts = self.getListOfDicts\n            else:\n                raise Exception(\n                    \"from Cache failed and no secondary cache via getListOfDicts specified\"\n                )\n        listOfDicts = getListOfDicts()\n        duration = time.time() - startTime\n        self.showProgress(\n            f\"got {len(listOfDicts)} {self.entityPluralName} in {duration:5.1f} s\"\n        )\n        self.cacheFile = self.storeLoD(\n            listOfDicts, append=append, sampleRecordCount=sampleRecordCount\n        )\n        self.setListFromLoD(listOfDicts)\n    else:\n        # fromStore also sets self.cacheFile\n        listOfDicts = self.fromStore()\n    return listOfDicts\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.fromStore","title":"<code>fromStore(cacheFile=None, setList=True)</code>","text":"<p>restore me from the store Args:     cacheFile(String): the cacheFile to use if None use the pre configured cachefile     setList(bool): if True set my list with the data from the cache file</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of dicts or JSON entitymanager</p> Source code in <code>lodentity/entity.py</code> <pre><code>    def fromStore(self, cacheFile=None, setList: bool = True) -&gt; list:\n        \"\"\"\n        restore me from the store\n        Args:\n            cacheFile(String): the cacheFile to use if None use the pre configured cachefile\n            setList(bool): if True set my list with the data from the cache file\n\n        Returns:\n            list: list of dicts or JSON entitymanager\n        \"\"\"\n        startTime = time.time()\n        if cacheFile is None:\n            cacheFile = self.getCacheFile(config=self.config, mode=self.config.mode)\n        self.cacheFile = cacheFile\n        self.showProgress(\n            \"reading %s for %s from cache %s\"\n            % (self.entityPluralName, self.name, cacheFile)\n        )\n        mode = self.config.mode\n        if mode is StoreMode.JSONPICKLE:\n            JSONem = JsonPickleMixin.readJsonPickle(cacheFile)\n            if self.clazz is not None:\n                listOfDicts = JSONem.getLoD()\n            else:\n                listOfDicts = JSONem.getList()\n        elif mode is StoreMode.JSON:\n            listOfDicts = self.readLodFromJsonFile(cacheFile)\n            pass\n        elif mode is StoreMode.SPARQL:\n            # @FIXME make abstract\n            eventQuery = (\n                \"\"\"\nPREFIX cr: &lt;http://cr.bitplan.com/&gt;\nSELECT ?eventId ?acronym ?series ?title ?year ?country ?city ?startDate ?endDate ?url ?source WHERE {\n   OPTIONAL { ?event cr:Event_eventId ?eventId. }\n   OPTIONAL { ?event cr:Event_acronym ?acronym. }\n   OPTIONAL { ?event cr:Event_series ?series. }\n   OPTIONAL { ?event cr:Event_title ?title. }\n   OPTIONAL { ?event cr:Event_year ?year.  }\n   OPTIONAL { ?event cr:Event_country ?country. }\n   OPTIONAL { ?event cr:Event_city ?city. }\n   OPTIONAL { ?event cr:Event_startDate ?startDate. }\n   OPTIONAL { ?event cr:Event_endDate ?endDate. }\n   OPTIONAL { ?event cr:Event_url ?url. }\n   ?event cr:Event_source ?source FILTER(?source='%s').\n}\n\"\"\"\n                % self.name\n            )\n            listOfDicts = self.sparql.queryAsListOfDicts(eventQuery)\n        elif mode is StoreMode.SQL:\n            sqlQuery = \"SELECT * FROM %s\" % self.tableName\n            sqlDB = self.getSQLDB(cacheFile)\n            listOfDicts = sqlDB.query(sqlQuery)\n            sqlDB.close()\n            pass\n        else:\n            raise Exception(\"unsupported store mode %s\" % self.mode)\n\n        self.showProgress(\n            \"read %d %s from %s in %5.1f s\"\n            % (\n                len(listOfDicts),\n                self.entityPluralName,\n                self.name,\n                time.time() - startTime,\n            )\n        )\n        if setList:\n            self.setListFromLoD(listOfDicts)\n        return listOfDicts\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.getCacheFile","title":"<code>getCacheFile(config=None, mode=StoreMode.SQL)</code>","text":"<p>get the cache file for this event manager Args:     config(StorageConfig): if None get the cache for my mode     mode(StoreMode): the storeMode to use</p> Source code in <code>lodentity/entity.py</code> <pre><code>def getCacheFile(self, config=None, mode=StoreMode.SQL):\n    \"\"\"\n    get the cache file for this event manager\n    Args:\n        config(StorageConfig): if None get the cache for my mode\n        mode(StoreMode): the storeMode to use\n    \"\"\"\n    if config is None:\n        config = self.config\n    cachedir = config.getCachePath()\n    if config.cacheFile is not None:\n        return config.cacheFile\n    \"\"\" get the path to the file for my cached data \"\"\"\n    if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n        extension = f\".{mode.name.lower()}\"\n        cachepath = f\"{cachedir}/{self.name}-{self.listName}{extension}\"\n    elif mode is StoreMode.SPARQL:\n        cachepath = f\"SPAQRL {self.name}:{config.endpoint}\"\n    elif mode is StoreMode.SQL:\n        cachepath = f\"{cachedir}/{self.name}.db\"\n    else:\n        cachepath = f\"undefined cachepath for StoreMode {mode}\"\n    return cachepath\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.getLoD","title":"<code>getLoD()</code>","text":"<p>Return the LoD of the entities in the list.</p> Return <p>list: a list of Dicts</p> Source code in <code>lodentity/entity.py</code> <pre><code>def getLoD(self):\n    \"\"\"Return the LoD of the entities in the list.\n\n    Return:\n        list: a list of Dicts\n    \"\"\"\n    lod = []\n    for entity in self.getList():\n        # TODO - optionally filter by samples\n        lod.append(entity.__dict__)\n    return lod\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.getSQLDB","title":"<code>getSQLDB(cacheFile)</code>","text":"<p>Get the SQL database for the given cacheFile.</p> <p>Parameters:</p> Name Type Description Default <code>cacheFile(string)</code> <p>the file to get the SQL db from</p> required Source code in <code>lodentity/entity.py</code> <pre><code>def getSQLDB(self, cacheFile):\n    \"\"\"Get the SQL database for the given cacheFile.\n\n    Args:\n        cacheFile(string): the file to get the SQL db from\n    \"\"\"\n    config = self.config\n    sqldb = self.sqldb = SQLDB(\n        cacheFile, debug=config.debug, errorDebug=config.errorDebug\n    )\n    return sqldb\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.initSQLDB","title":"<code>initSQLDB(sqldb, listOfDicts=None, withCreate=True, withDrop=True, sampleRecordCount=-1)</code>","text":"<p>Initialize my sql DB.</p> <p>Parameters:</p> Name Type Description Default <code>listOfDicts(list)</code> <p>the list of dicts to analyze for type information</p> required <code>withDrop(boolean)</code> <p>true if the existing Table should be dropped</p> required <code>withCreate(boolean)</code> <p>true if the create Table command should be executed - false if only the entityInfo should be returned</p> required <code>sampleRecordCount(int)</code> <p>the number of records to analyze for type information</p> required <p>Return:     EntityInfo: the entity information such as CREATE Table command</p> Source code in <code>lodentity/entity.py</code> <pre><code>def initSQLDB(\n    self,\n    sqldb,\n    listOfDicts=None,\n    withCreate: bool = True,\n    withDrop: bool = True,\n    sampleRecordCount=-1,\n):\n    \"\"\"Initialize my sql DB.\n\n    Args:\n        listOfDicts(list): the list of dicts to analyze for type information\n        withDrop(boolean): true if the existing Table should be dropped\n        withCreate(boolean): true if the create Table command should be executed - false if only the entityInfo should be returned\n        sampleRecordCount(int): the number of records to analyze for type information\n    Return:\n        EntityInfo: the entity information such as CREATE Table command\n    \"\"\"\n    if listOfDicts is None:\n        listOfDicts = JSONAble.getJsonTypeSamplesForClass(self.clazz)\n    entityInfo = sqldb.createTable(\n        listOfDicts,\n        self.tableName,\n        primaryKey=self.primaryKey,\n        withCreate=withCreate,\n        withDrop=withDrop,\n        sampleRecordCount=sampleRecordCount,\n    )\n    return entityInfo\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.isCached","title":"<code>isCached()</code>","text":"<p>Check whether there is a file containing cached data for me.</p> Source code in <code>lodentity/entity.py</code> <pre><code>    def isCached(self):\n        \"\"\"Check whether there is a file containing cached data for me.\"\"\"\n        result = False\n        config = self.config\n        mode = self.config.mode\n        if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n            result = os.path.isfile(self.getCacheFile(config=self.config, mode=mode))\n        elif mode is StoreMode.SPARQL:\n            # @FIXME - make abstract\n            query = (\n                config.prefix\n                + \"\"\"\nSELECT  ?source (COUNT(?source) AS ?sourcecount)\nWHERE {\n   ?event cr:Event_source ?source.\n}\nGROUP by ?source\n\"\"\"\n            )\n            sourceCountList = self.sparql.queryAsListOfDicts(query)\n            for sourceCount in sourceCountList:\n                source = sourceCount[\"source\"]\n                recordCount = sourceCount[\"sourcecount\"]\n                if source == self.name and recordCount &gt; 100:\n                    result = True\n        elif mode is StoreMode.SQL:\n            cacheFile = self.getCacheFile(config=self.config, mode=StoreMode.SQL)\n            if os.path.isfile(cacheFile):\n                sqlQuery = f\"SELECT COUNT(*) AS count FROM {self.tableName}\"\n                try:\n                    sqlDB = self.getSQLDB(cacheFile)\n                    countResults = sqlDB.query(sqlQuery)\n                    countResult = countResults[0]\n                    count = countResult[\"count\"]\n                    result = count &gt;= 0\n                except Exception as ex:\n                    msg = str(ex)\n                    if self.debug:\n                        print(msg, file=sys.stderr)\n                        sys.stderr.flush()\n                    # e.g. sqlite3.OperationalError: no such table: Event_crossref\n                    pass\n        else:\n            raise Exception(\"unsupported mode %s\" % self.mode)\n        return result\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.removeCacheFile","title":"<code>removeCacheFile()</code>","text":"<p>Remove my cache file.</p> Source code in <code>lodentity/entity.py</code> <pre><code>def removeCacheFile(self):\n    \"\"\"Remove my cache file.\"\"\"\n    mode = self.config.mode\n    if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n        cacheFile = self.getCacheFile(mode=mode)\n        if os.path.isfile(cacheFile):\n            os.remove(cacheFile)\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.setNone","title":"<code>setNone(record, fields)</code>","text":"<p>make sure the given fields in the given record are set to none Args:     record(dict): the record to work on     fields(list): the list of fields to set to None</p> Source code in <code>lodentity/entity.py</code> <pre><code>def setNone(self, record, fields):\n    \"\"\"\n    make sure the given fields in the given record are set to none\n    Args:\n        record(dict): the record to work on\n        fields(list): the list of fields to set to None\n    \"\"\"\n    LOD.setNone(record, fields)\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.showProgress","title":"<code>showProgress(msg)</code>","text":"<p>Display a progress message.</p> <p>Parameters:</p> Name Type Description Default <code>msg(string)</code> <p>the message to display</p> required Source code in <code>lodentity/entity.py</code> <pre><code>def showProgress(self, msg):\n    \"\"\"Display a progress message.\n\n    Args:\n      msg(string): the message to display\n    \"\"\"\n    if self.config.withShowProgress:\n        print(msg, flush=True)\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.store","title":"<code>store(limit=10000000, batchSize=250, append=False, fixNone=True, sampleRecordCount=-1, replace=False)</code>","text":"<p>Store my list of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>limit(int)</code> <p>maximum number of records to store per batch</p> required <code>batchSize(int)</code> <p>size of batch for storing</p> required <code>append(bool)</code> <p>True if records should be appended</p> required <code>fixNone(bool)</code> <p>if True make sure the dicts are filled with None references for each record</p> required <code>sampleRecordCount(int)</code> <p>the number of records to analyze for type information</p> required <code>replace(bool)</code> <p>if True allow replace for insert</p> required Return <p>str: The cachefile being used</p> Source code in <code>lodentity/entity.py</code> <pre><code>def store(\n    self,\n    limit=10000000,\n    batchSize=250,\n    append=False,\n    fixNone=True,\n    sampleRecordCount=-1,\n    replace: bool = False,\n) -&gt; str:\n    \"\"\"Store my list of dicts.\n\n    Args:\n        limit(int): maximum number of records to store per batch\n        batchSize(int): size of batch for storing\n        append(bool): True if records should be appended\n        fixNone(bool): if True make sure the dicts are filled with None references for each record\n        sampleRecordCount(int): the number of records to analyze for type information\n        replace(bool): if True allow replace for insert\n\n    Return:\n        str: The cachefile being used\n    \"\"\"\n    lod = self.getLoD()\n    return self.storeLoD(\n        lod,\n        limit=limit,\n        batchSize=batchSize,\n        append=append,\n        fixNone=fixNone,\n        sampleRecordCount=sampleRecordCount,\n        replace=replace,\n    )\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.storeLoD","title":"<code>storeLoD(listOfDicts, limit=10000000, batchSize=250, cacheFile=None, append=False, fixNone=True, sampleRecordCount=1, replace=False)</code>","text":"<p>Store my entities.</p> <p>Parameters:</p> Name Type Description Default <code>listOfDicts(list)</code> <p>the list of dicts to store</p> required <code>limit(int)</code> <p>maximum number of records to store</p> required <code>batchSize(int)</code> <p>size of batch for storing</p> required <code>cacheFile(string)</code> <p>the name of the storage e.g path to JSON or sqlite3 file</p> required <code>append(bool)</code> <p>True if records should be appended</p> required <code>fixNone(bool)</code> <p>if True make sure the dicts are filled with None references for each record</p> required <code>sampleRecordCount(int)</code> <p>the number of records to analyze for type information</p> required <code>replace(bool)</code> <p>if True allow replace for insert</p> required <p>Return:     str: The cachefile being used</p> Source code in <code>lodentity/entity.py</code> <pre><code>def storeLoD(\n    self,\n    listOfDicts,\n    limit=10000000,\n    batchSize=250,\n    cacheFile=None,\n    append=False,\n    fixNone=True,\n    sampleRecordCount=1,\n    replace: bool = False,\n) -&gt; str:\n    \"\"\"Store my entities.\n\n    Args:\n        listOfDicts(list): the list of dicts to store\n        limit(int): maximum number of records to store\n        batchSize(int): size of batch for storing\n        cacheFile(string): the name of the storage e.g path to JSON or sqlite3 file\n        append(bool): True if records should be appended\n        fixNone(bool): if True make sure the dicts are filled with None references for each record\n        sampleRecordCount(int): the number of records to analyze for type information\n        replace(bool): if True allow replace for insert\n    Return:\n        str: The cachefile being used\n    \"\"\"\n    config = self.config\n    mode = config.mode\n    if self.handleInvalidListTypes:\n        LOD.handleListTypes(\n            lod=listOfDicts,\n            doFilter=self.filterInvalidListTypes,\n            separator=self.listSeparator,\n        )\n    if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n        if cacheFile is None:\n            cacheFile = self.getCacheFile(config=self.config, mode=mode)\n        self.showProgress(\n            f\"storing {len(listOfDicts)} {self.entityPluralName} for {self.name} to cache {cacheFile}\"\n        )\n        if mode is StoreMode.JSONPICKLE:\n            self.writeJsonPickle(cacheFile)\n        if mode is StoreMode.JSON:\n            self.storeToJsonFile(cacheFile)\n            pass\n    elif mode is StoreMode.SPARQL:\n        startTime = time.time()\n        msg = f\"storing {len(listOfDicts)} {self.entityPluralName} to {self.config.mode} ({self.config.endpoint})\"\n        self.showProgress(msg)\n        # @ FIXME make abstract /configurable\n        entityType = \"cr:Event\"\n        prefixes = self.config.prefix\n        self.sparql.insertListOfDicts(\n            listOfDicts,\n            entityType,\n            self.primaryKey,\n            prefixes,\n            limit=limit,\n            batchSize=batchSize,\n        )\n        self.showProgress(\n            \"store for %s done after %5.1f secs\"\n            % (self.name, time.time() - startTime)\n        )\n    elif mode is StoreMode.SQL:\n        startTime = time.time()\n        if cacheFile is None:\n            cacheFile = self.getCacheFile(config=self.config, mode=self.config.mode)\n        sqldb = self.getSQLDB(cacheFile)\n        self.showProgress(\n            \"storing %d %s for %s to %s:%s\"\n            % (\n                len(listOfDicts),\n                self.entityPluralName,\n                self.name,\n                config.mode,\n                cacheFile,\n            )\n        )\n        if append:\n            withDrop = False\n            withCreate = False\n        else:\n            withDrop = True\n            withCreate = True\n        entityInfo = self.initSQLDB(\n            sqldb,\n            listOfDicts,\n            withCreate=withCreate,\n            withDrop=withDrop,\n            sampleRecordCount=sampleRecordCount,\n        )\n        self.sqldb.store(\n            listOfDicts,\n            entityInfo,\n            executeMany=self.executeMany,\n            fixNone=fixNone,\n            replace=replace,\n        )\n        self.showProgress(\n            \"store for %s done after %5.1f secs\"\n            % (self.name, time.time() - startTime)\n        )\n    else:\n        raise Exception(f\"unsupported store mode {self.mode}\")\n    return cacheFile\n</code></pre>"},{"location":"#lodentity.entity.EntityManager.storeMode","title":"<code>storeMode()</code>","text":"<p>Return my store mode.</p> Source code in <code>lodentity/entity.py</code> <pre><code>def storeMode(self):\n    \"\"\"Return my store mode.\"\"\"\n    return self.config.mode\n</code></pre>"},{"location":"#lodentity.jsonable","title":"<code>jsonable</code>","text":"<p>This module has a class JSONAble for serialization of tables/list of dicts to and from JSON encoding.</p> <p>Created on 2020-09-03</p> <p>@author: wf</p>"},{"location":"#lodentity.jsonable.JSONAble","title":"<code>JSONAble</code>","text":"<p>               Bases: <code>object</code></p> <p>Mixin to allow classes to be JSON serializable see.</p> <ul> <li>https://stackoverflow.com/questions/3768895/how-to-make-a-class-json-serializable</li> </ul> Source code in <code>lodentity/jsonable.py</code> <pre><code>class JSONAble(object):\n    \"\"\"Mixin to allow classes to be JSON serializable see.\n\n    - https://stackoverflow.com/questions/3768895/how-to-make-a-class-json-serializable\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor.\"\"\"\n\n    @classmethod\n    def getPluralname(cls):\n        return \"%ss\" % cls.__name__\n\n    @staticmethod\n    def singleQuoteToDoubleQuote(singleQuoted, useRegex=False):\n        \"\"\"Convert a single quoted string to a double quoted one.\n\n        Args:\n            singleQuoted (str): a single quoted string e.g.\n\n                .. highlight:: json\n\n                {'cities': [{'name': \"Upper Hell's Gate\"}]}\n\n            useRegex (boolean): True if a regular expression shall be used for matching\n\n        Returns:\n            string: the double quoted version of the string\n\n        Note:\n            see\n            - https://stackoverflow.com/questions/55600788/python-replace-single-quotes-with-double-quotes-but-leave-ones-within-double-q\n        \"\"\"\n        if useRegex:\n            doubleQuoted = JSONAble.singleQuoteToDoubleQuoteUsingRegex(singleQuoted)\n        else:\n            doubleQuoted = JSONAble.singleQuoteToDoubleQuoteUsingBracketLoop(\n                singleQuoted\n            )\n        return doubleQuoted\n\n    @staticmethod\n    def singleQuoteToDoubleQuoteUsingRegex(singleQuoted):\n        \"\"\"Convert a single quoted string to a double quoted one using a\n        regular expression.\n\n        Args:\n            singleQuoted(string): a single quoted string e.g. {'cities': [{'name': \"Upper Hell's Gate\"}]}\n            useRegex(boolean): True if a regular expression shall be used for matching\n        Returns:\n            string: the double quoted version of the string e.g.\n        Note:\n            see https://stackoverflow.com/a/50257217/1497139\n        \"\"\"\n        doubleQuoted = JSONAbleSettings.singleQuoteRegex.sub('\"', singleQuoted)\n        return doubleQuoted\n\n    @staticmethod\n    def singleQuoteToDoubleQuoteUsingBracketLoop(singleQuoted):\n        \"\"\"Convert a single quoted string to a double quoted one using a\n        regular expression.\n\n        Args:\n            singleQuoted(string): a single quoted string e.g. {'cities': [{'name': \"Upper Hell's Gate\"}]}\n            useRegex(boolean): True if a regular expression shall be used for matching\n        Returns:\n            string: the double quoted version of the string e.g.\n        Note:\n            see https://stackoverflow.com/a/63862387/1497139\n        \"\"\"\n        cList = list(singleQuoted)\n        inDouble = False\n        inSingle = False\n        for i, c in enumerate(cList):\n            # print (\"%d:%s %r %r\" %(i,c,inSingle,inDouble))\n            if c == \"'\":\n                if not inDouble:\n                    inSingle = not inSingle\n                    cList[i] = '\"'\n            elif c == '\"':\n                inDouble = not inDouble\n                inSingle = False\n        doubleQuoted = \"\".join(cList)\n        return doubleQuoted\n\n    def getJsonTypeSamples(self):\n        \"\"\"Does my class provide a \"getSamples\" method?\"\"\"\n        if hasattr(self, \"__class__\"):\n            cls = self.__class__\n            if isinstance(self, JSONAbleList) and not hasattr(cls, \"getSamples\"):\n                cls = self.clazz\n            return JSONAble.getJsonTypeSamplesForClass(cls)\n        return None\n\n    @staticmethod\n    def getJsonTypeSamplesForClass(cls):\n        \"\"\"Return the type samples for the given class.\n\n        Return:\n            list: a list of dict that specify the types by example\n        \"\"\"\n        if hasattr(cls, \"getSamples\"):\n            getSamples = getattr(cls, \"getSamples\")\n            if callable(getSamples):\n                return getSamples()\n        return None\n\n    @staticmethod\n    def readJsonFromFile(jsonFilePath):\n        \"\"\"Read json string from the given jsonFilePath.\n\n        Args:\n            jsonFilePath(string): the path of the file where to read the result from\n\n        Returns:\n            the JSON string read from the file\n        \"\"\"\n        with open(jsonFilePath, \"r\") as jsonFile:\n            jsonStr = jsonFile.read()\n        return jsonStr\n\n    @staticmethod\n    def storeJsonToFile(jsonStr, jsonFilePath):\n        \"\"\"Store the given json string to the given jsonFilePath.\n\n        Args:\n            jsonStr(string): the string to store\n            jsonFilePath(string): the path of the file where to store the result\n        \"\"\"\n        with open(jsonFilePath, \"w\") as jsonFile:\n            jsonFile.write(jsonStr)\n\n    def checkExtension(self, jsonFile: str, extension: str = \".json\") -&gt; str:\n        \"\"\"Make sure the jsonFile has the given extension e.g. \".json\".\n\n        Args:\n            jsonFile(str): the jsonFile name - potentially without \".json\" suffix\n\n        Returns:\n            str: the jsonFile name with \".json\" as an extension guaranteed\n        \"\"\"\n        if not jsonFile.endswith(extension):\n            jsonFile = f\"{jsonFile}{extension}\"\n        return jsonFile\n\n    def storeToJsonFile(\n        self, jsonFile: str, extension: str = \".json\", limitToSampleFields: bool = False\n    ):\n        \"\"\"Store me to the given jsonFile.\n\n        Args:\n            jsonFile(str): the JSON file name (optionally without extension)\n            exension(str): the extension to use if not part of the jsonFile name\n            limitToSampleFields(bool): If True the returned JSON is limited to the attributes/fields that are present in the samples. Otherwise all attributes of the object will be included. Default is False.\n        \"\"\"\n        jsonFile = self.checkExtension(jsonFile, extension)\n        JSONAble.storeJsonToFile(self.toJSON(limitToSampleFields), jsonFile)\n\n    def restoreFromJsonFile(self, jsonFile: str):\n        \"\"\"Restore me from the given jsonFile.\n\n        Args:\n            jsonFile(string): the jsonFile to restore me from\n        \"\"\"\n        jsonFile = self.checkExtension(jsonFile)\n        jsonStr = JSONAble.readJsonFromFile(jsonFile)\n        self.fromJson(jsonStr)\n\n    def fromJson(self, jsonStr):\n        \"\"\"Initialize me from the given JSON string.\n\n        Args:\n            jsonStr(str): the JSON string\n        \"\"\"\n        jsonMap = json.loads(jsonStr)\n        self.fromDict(jsonMap)\n\n    def fromDict(self, data: dict):\n        \"\"\"Initialize me from the given data.\n\n        Args:\n            data(dict): the dictionary to initialize me from\n        \"\"\"\n        # https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression-in-python-taking-union-o\n        for key in data.keys():\n            value = data[key]\n            setattr(self, key, value)\n\n    def toJsonAbleValue(self, v):\n        \"\"\"\n        return the JSON able value of the given value v\n        Args:\n            v(object): the value to convert\n        \"\"\"\n        # objects have __dict__ hash tables which can be JSON-converted\n        if hasattr(v, \"__dict__\"):\n            return v.__dict__\n        elif isinstance(v, datetime.datetime):\n            return v.isoformat()\n        elif isinstance(v, datetime.date):\n            return v.isoformat()\n        else:\n            return \"\"\n\n    def toJSON(self, limitToSampleFields: bool = False):\n        \"\"\"\n\n        Args:\n            limitToSampleFields(bool): If True the returned JSON is limited to the attributes/fields that are present in the samples. Otherwise all attributes of the object will be included. Default is False.\n\n        Returns:\n            a recursive JSON dump of the dicts of my objects\n        \"\"\"\n        data = {}\n        if limitToSampleFields:\n            samples = self.getJsonTypeSamples()\n            sampleFields = LOD.getFields(samples)\n            if isinstance(self, JSONAbleList):\n                limitedRecords = []\n                for record in self.__dict__[self.listName]:\n                    limitedRecord = {}\n                    for key, value in record.__dict__.items():\n                        if key in sampleFields:\n                            limitedRecord[key] = value\n                    limitedRecords.append(limitedRecord)\n                data[self.listName] = limitedRecords\n            else:\n                for key, value in self.__dict__.items():\n                    if key in sampleFields:\n                        data[key] = value\n        else:\n            data = self\n        jsonStr = json.dumps(\n            data,\n            default=lambda v: self.toJsonAbleValue(v),\n            sort_keys=True,\n            indent=JSONAbleSettings.indent,\n        )\n        return jsonStr\n\n    def getJSONValue(self, v):\n        \"\"\"Get the value of the given v as JSON.\n\n        Args:\n            v(object): the value to get\n\n        Returns:\n            the the value making sure objects are return as dicts\n        \"\"\"\n        if hasattr(v, \"asJSON\"):\n            return v.asJSON(asString=False)\n        elif type(v) is dict:\n            return self.reprDict(v)\n        elif type(v) is list:\n            vlist = []\n            for vitem in v:\n                vlist.append(self.getJSONValue(vitem))\n            return vlist\n        elif isinstance(v, datetime.datetime):\n            return v.isoformat()\n        elif isinstance(v, datetime.date):\n            return v.isoformat()\n        elif isinstance(v, bool):\n            # convert True,False to -&gt; true,false\n            return str(v).lower()\n        else:\n            return v\n\n    def reprDict(self, srcDict):\n        \"\"\"Get the given srcDict as new dict with fields being converted with\n        getJSONValue.\n\n        Args:\n            scrcDict(dict): the source dictionary\n\n        Returns\n            dict: the converted dictionary\n        \"\"\"\n        d = dict()\n        for a, v in srcDict.items():\n            d[a] = self.getJSONValue(v)\n        return d\n\n    def asJSON(self, asString=True, data=None):\n        \"\"\"Recursively return my dict elements.\n\n        Args:\n            asString(boolean): if True return my result as a string\n        \"\"\"\n        if data is None:\n            data = self.__dict__\n        jsonDict = self.reprDict(data)\n        if asString:\n            jsonStr = str(jsonDict)\n            jsonStr = JSONAble.singleQuoteToDoubleQuote(jsonStr)\n            return jsonStr\n        return jsonDict\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.__init__","title":"<code>__init__()</code>","text":"<p>Constructor.</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructor.\"\"\"\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.asJSON","title":"<code>asJSON(asString=True, data=None)</code>","text":"<p>Recursively return my dict elements.</p> <p>Parameters:</p> Name Type Description Default <code>asString(boolean)</code> <p>if True return my result as a string</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def asJSON(self, asString=True, data=None):\n    \"\"\"Recursively return my dict elements.\n\n    Args:\n        asString(boolean): if True return my result as a string\n    \"\"\"\n    if data is None:\n        data = self.__dict__\n    jsonDict = self.reprDict(data)\n    if asString:\n        jsonStr = str(jsonDict)\n        jsonStr = JSONAble.singleQuoteToDoubleQuote(jsonStr)\n        return jsonStr\n    return jsonDict\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.checkExtension","title":"<code>checkExtension(jsonFile, extension='.json')</code>","text":"<p>Make sure the jsonFile has the given extension e.g. \".json\".</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile(str)</code> <p>the jsonFile name - potentially without \".json\" suffix</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the jsonFile name with \".json\" as an extension guaranteed</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def checkExtension(self, jsonFile: str, extension: str = \".json\") -&gt; str:\n    \"\"\"Make sure the jsonFile has the given extension e.g. \".json\".\n\n    Args:\n        jsonFile(str): the jsonFile name - potentially without \".json\" suffix\n\n    Returns:\n        str: the jsonFile name with \".json\" as an extension guaranteed\n    \"\"\"\n    if not jsonFile.endswith(extension):\n        jsonFile = f\"{jsonFile}{extension}\"\n    return jsonFile\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.fromDict","title":"<code>fromDict(data)</code>","text":"<p>Initialize me from the given data.</p> <p>Parameters:</p> Name Type Description Default <code>data(dict)</code> <p>the dictionary to initialize me from</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def fromDict(self, data: dict):\n    \"\"\"Initialize me from the given data.\n\n    Args:\n        data(dict): the dictionary to initialize me from\n    \"\"\"\n    # https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression-in-python-taking-union-o\n    for key in data.keys():\n        value = data[key]\n        setattr(self, key, value)\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.fromJson","title":"<code>fromJson(jsonStr)</code>","text":"<p>Initialize me from the given JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>jsonStr(str)</code> <p>the JSON string</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def fromJson(self, jsonStr):\n    \"\"\"Initialize me from the given JSON string.\n\n    Args:\n        jsonStr(str): the JSON string\n    \"\"\"\n    jsonMap = json.loads(jsonStr)\n    self.fromDict(jsonMap)\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.getJSONValue","title":"<code>getJSONValue(v)</code>","text":"<p>Get the value of the given v as JSON.</p> <p>Parameters:</p> Name Type Description Default <code>v(object)</code> <p>the value to get</p> required <p>Returns:</p> Type Description <p>the the value making sure objects are return as dicts</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def getJSONValue(self, v):\n    \"\"\"Get the value of the given v as JSON.\n\n    Args:\n        v(object): the value to get\n\n    Returns:\n        the the value making sure objects are return as dicts\n    \"\"\"\n    if hasattr(v, \"asJSON\"):\n        return v.asJSON(asString=False)\n    elif type(v) is dict:\n        return self.reprDict(v)\n    elif type(v) is list:\n        vlist = []\n        for vitem in v:\n            vlist.append(self.getJSONValue(vitem))\n        return vlist\n    elif isinstance(v, datetime.datetime):\n        return v.isoformat()\n    elif isinstance(v, datetime.date):\n        return v.isoformat()\n    elif isinstance(v, bool):\n        # convert True,False to -&gt; true,false\n        return str(v).lower()\n    else:\n        return v\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.getJsonTypeSamples","title":"<code>getJsonTypeSamples()</code>","text":"<p>Does my class provide a \"getSamples\" method?</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def getJsonTypeSamples(self):\n    \"\"\"Does my class provide a \"getSamples\" method?\"\"\"\n    if hasattr(self, \"__class__\"):\n        cls = self.__class__\n        if isinstance(self, JSONAbleList) and not hasattr(cls, \"getSamples\"):\n            cls = self.clazz\n        return JSONAble.getJsonTypeSamplesForClass(cls)\n    return None\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.getJsonTypeSamplesForClass","title":"<code>getJsonTypeSamplesForClass()</code>  <code>staticmethod</code>","text":"<p>Return the type samples for the given class.</p> Return <p>list: a list of dict that specify the types by example</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>@staticmethod\ndef getJsonTypeSamplesForClass(cls):\n    \"\"\"Return the type samples for the given class.\n\n    Return:\n        list: a list of dict that specify the types by example\n    \"\"\"\n    if hasattr(cls, \"getSamples\"):\n        getSamples = getattr(cls, \"getSamples\")\n        if callable(getSamples):\n            return getSamples()\n    return None\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.readJsonFromFile","title":"<code>readJsonFromFile(jsonFilePath)</code>  <code>staticmethod</code>","text":"<p>Read json string from the given jsonFilePath.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFilePath(string)</code> <p>the path of the file where to read the result from</p> required <p>Returns:</p> Type Description <p>the JSON string read from the file</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>@staticmethod\ndef readJsonFromFile(jsonFilePath):\n    \"\"\"Read json string from the given jsonFilePath.\n\n    Args:\n        jsonFilePath(string): the path of the file where to read the result from\n\n    Returns:\n        the JSON string read from the file\n    \"\"\"\n    with open(jsonFilePath, \"r\") as jsonFile:\n        jsonStr = jsonFile.read()\n    return jsonStr\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.reprDict","title":"<code>reprDict(srcDict)</code>","text":"<p>Get the given srcDict as new dict with fields being converted with getJSONValue.</p> <p>Parameters:</p> Name Type Description Default <code>scrcDict(dict)</code> <p>the source dictionary</p> required <p>Returns     dict: the converted dictionary</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def reprDict(self, srcDict):\n    \"\"\"Get the given srcDict as new dict with fields being converted with\n    getJSONValue.\n\n    Args:\n        scrcDict(dict): the source dictionary\n\n    Returns\n        dict: the converted dictionary\n    \"\"\"\n    d = dict()\n    for a, v in srcDict.items():\n        d[a] = self.getJSONValue(v)\n    return d\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.restoreFromJsonFile","title":"<code>restoreFromJsonFile(jsonFile)</code>","text":"<p>Restore me from the given jsonFile.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile(string)</code> <p>the jsonFile to restore me from</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def restoreFromJsonFile(self, jsonFile: str):\n    \"\"\"Restore me from the given jsonFile.\n\n    Args:\n        jsonFile(string): the jsonFile to restore me from\n    \"\"\"\n    jsonFile = self.checkExtension(jsonFile)\n    jsonStr = JSONAble.readJsonFromFile(jsonFile)\n    self.fromJson(jsonStr)\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.singleQuoteToDoubleQuote","title":"<code>singleQuoteToDoubleQuote(singleQuoted, useRegex=False)</code>  <code>staticmethod</code>","text":"<p>Convert a single quoted string to a double quoted one.</p> <p>Parameters:</p> Name Type Description Default <code>singleQuoted</code> <code>str</code> <p>a single quoted string e.g.</p> <p>.. highlight:: json</p> <p>{'cities': [{'name': \"Upper Hell's Gate\"}]}</p> required <code>useRegex</code> <code>boolean</code> <p>True if a regular expression shall be used for matching</p> <code>False</code> <p>Returns:</p> Name Type Description <code>string</code> <p>the double quoted version of the string</p> Note <p>see - https://stackoverflow.com/questions/55600788/python-replace-single-quotes-with-double-quotes-but-leave-ones-within-double-q</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>@staticmethod\ndef singleQuoteToDoubleQuote(singleQuoted, useRegex=False):\n    \"\"\"Convert a single quoted string to a double quoted one.\n\n    Args:\n        singleQuoted (str): a single quoted string e.g.\n\n            .. highlight:: json\n\n            {'cities': [{'name': \"Upper Hell's Gate\"}]}\n\n        useRegex (boolean): True if a regular expression shall be used for matching\n\n    Returns:\n        string: the double quoted version of the string\n\n    Note:\n        see\n        - https://stackoverflow.com/questions/55600788/python-replace-single-quotes-with-double-quotes-but-leave-ones-within-double-q\n    \"\"\"\n    if useRegex:\n        doubleQuoted = JSONAble.singleQuoteToDoubleQuoteUsingRegex(singleQuoted)\n    else:\n        doubleQuoted = JSONAble.singleQuoteToDoubleQuoteUsingBracketLoop(\n            singleQuoted\n        )\n    return doubleQuoted\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.singleQuoteToDoubleQuoteUsingBracketLoop","title":"<code>singleQuoteToDoubleQuoteUsingBracketLoop(singleQuoted)</code>  <code>staticmethod</code>","text":"<p>Convert a single quoted string to a double quoted one using a regular expression.</p> <p>Parameters:</p> Name Type Description Default <code>singleQuoted(string)</code> <p>a single quoted string e.g. {'cities': [{'name': \"Upper Hell's Gate\"}]}</p> required <code>useRegex(boolean)</code> <p>True if a regular expression shall be used for matching</p> required <p>Returns:     string: the double quoted version of the string e.g. Note:     see https://stackoverflow.com/a/63862387/1497139</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>@staticmethod\ndef singleQuoteToDoubleQuoteUsingBracketLoop(singleQuoted):\n    \"\"\"Convert a single quoted string to a double quoted one using a\n    regular expression.\n\n    Args:\n        singleQuoted(string): a single quoted string e.g. {'cities': [{'name': \"Upper Hell's Gate\"}]}\n        useRegex(boolean): True if a regular expression shall be used for matching\n    Returns:\n        string: the double quoted version of the string e.g.\n    Note:\n        see https://stackoverflow.com/a/63862387/1497139\n    \"\"\"\n    cList = list(singleQuoted)\n    inDouble = False\n    inSingle = False\n    for i, c in enumerate(cList):\n        # print (\"%d:%s %r %r\" %(i,c,inSingle,inDouble))\n        if c == \"'\":\n            if not inDouble:\n                inSingle = not inSingle\n                cList[i] = '\"'\n        elif c == '\"':\n            inDouble = not inDouble\n            inSingle = False\n    doubleQuoted = \"\".join(cList)\n    return doubleQuoted\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.singleQuoteToDoubleQuoteUsingRegex","title":"<code>singleQuoteToDoubleQuoteUsingRegex(singleQuoted)</code>  <code>staticmethod</code>","text":"<p>Convert a single quoted string to a double quoted one using a regular expression.</p> <p>Parameters:</p> Name Type Description Default <code>singleQuoted(string)</code> <p>a single quoted string e.g. {'cities': [{'name': \"Upper Hell's Gate\"}]}</p> required <code>useRegex(boolean)</code> <p>True if a regular expression shall be used for matching</p> required <p>Returns:     string: the double quoted version of the string e.g. Note:     see https://stackoverflow.com/a/50257217/1497139</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>@staticmethod\ndef singleQuoteToDoubleQuoteUsingRegex(singleQuoted):\n    \"\"\"Convert a single quoted string to a double quoted one using a\n    regular expression.\n\n    Args:\n        singleQuoted(string): a single quoted string e.g. {'cities': [{'name': \"Upper Hell's Gate\"}]}\n        useRegex(boolean): True if a regular expression shall be used for matching\n    Returns:\n        string: the double quoted version of the string e.g.\n    Note:\n        see https://stackoverflow.com/a/50257217/1497139\n    \"\"\"\n    doubleQuoted = JSONAbleSettings.singleQuoteRegex.sub('\"', singleQuoted)\n    return doubleQuoted\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.storeJsonToFile","title":"<code>storeJsonToFile(jsonStr, jsonFilePath)</code>  <code>staticmethod</code>","text":"<p>Store the given json string to the given jsonFilePath.</p> <p>Parameters:</p> Name Type Description Default <code>jsonStr(string)</code> <p>the string to store</p> required <code>jsonFilePath(string)</code> <p>the path of the file where to store the result</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>@staticmethod\ndef storeJsonToFile(jsonStr, jsonFilePath):\n    \"\"\"Store the given json string to the given jsonFilePath.\n\n    Args:\n        jsonStr(string): the string to store\n        jsonFilePath(string): the path of the file where to store the result\n    \"\"\"\n    with open(jsonFilePath, \"w\") as jsonFile:\n        jsonFile.write(jsonStr)\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.storeToJsonFile","title":"<code>storeToJsonFile(jsonFile, extension='.json', limitToSampleFields=False)</code>","text":"<p>Store me to the given jsonFile.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile(str)</code> <p>the JSON file name (optionally without extension)</p> required <code>exension(str)</code> <p>the extension to use if not part of the jsonFile name</p> required <code>limitToSampleFields(bool)</code> <p>If True the returned JSON is limited to the attributes/fields that are present in the samples. Otherwise all attributes of the object will be included. Default is False.</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def storeToJsonFile(\n    self, jsonFile: str, extension: str = \".json\", limitToSampleFields: bool = False\n):\n    \"\"\"Store me to the given jsonFile.\n\n    Args:\n        jsonFile(str): the JSON file name (optionally without extension)\n        exension(str): the extension to use if not part of the jsonFile name\n        limitToSampleFields(bool): If True the returned JSON is limited to the attributes/fields that are present in the samples. Otherwise all attributes of the object will be included. Default is False.\n    \"\"\"\n    jsonFile = self.checkExtension(jsonFile, extension)\n    JSONAble.storeJsonToFile(self.toJSON(limitToSampleFields), jsonFile)\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.toJSON","title":"<code>toJSON(limitToSampleFields=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>limitToSampleFields(bool)</code> <p>If True the returned JSON is limited to the attributes/fields that are present in the samples. Otherwise all attributes of the object will be included. Default is False.</p> required <p>Returns:</p> Type Description <p>a recursive JSON dump of the dicts of my objects</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def toJSON(self, limitToSampleFields: bool = False):\n    \"\"\"\n\n    Args:\n        limitToSampleFields(bool): If True the returned JSON is limited to the attributes/fields that are present in the samples. Otherwise all attributes of the object will be included. Default is False.\n\n    Returns:\n        a recursive JSON dump of the dicts of my objects\n    \"\"\"\n    data = {}\n    if limitToSampleFields:\n        samples = self.getJsonTypeSamples()\n        sampleFields = LOD.getFields(samples)\n        if isinstance(self, JSONAbleList):\n            limitedRecords = []\n            for record in self.__dict__[self.listName]:\n                limitedRecord = {}\n                for key, value in record.__dict__.items():\n                    if key in sampleFields:\n                        limitedRecord[key] = value\n                limitedRecords.append(limitedRecord)\n            data[self.listName] = limitedRecords\n        else:\n            for key, value in self.__dict__.items():\n                if key in sampleFields:\n                    data[key] = value\n    else:\n        data = self\n    jsonStr = json.dumps(\n        data,\n        default=lambda v: self.toJsonAbleValue(v),\n        sort_keys=True,\n        indent=JSONAbleSettings.indent,\n    )\n    return jsonStr\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAble.toJsonAbleValue","title":"<code>toJsonAbleValue(v)</code>","text":"<p>return the JSON able value of the given value v Args:     v(object): the value to convert</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def toJsonAbleValue(self, v):\n    \"\"\"\n    return the JSON able value of the given value v\n    Args:\n        v(object): the value to convert\n    \"\"\"\n    # objects have __dict__ hash tables which can be JSON-converted\n    if hasattr(v, \"__dict__\"):\n        return v.__dict__\n    elif isinstance(v, datetime.datetime):\n        return v.isoformat()\n    elif isinstance(v, datetime.date):\n        return v.isoformat()\n    else:\n        return \"\"\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList","title":"<code>JSONAbleList</code>","text":"<p>               Bases: <code>JSONAble</code></p> <p>Container class.</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>class JSONAbleList(JSONAble):\n    \"\"\"Container class.\"\"\"\n\n    def __init__(\n        self,\n        listName: str = None,\n        clazz=None,\n        tableName: str = None,\n        initList: bool = True,\n        handleInvalidListTypes=False,\n        filterInvalidListTypes=False,\n    ):\n        \"\"\"Constructor.\n\n        Args:\n            listName(str): the name of the list attribute to be used for storing the List\n            clazz(class): a class to be used for Object relational mapping (if any)\n            tableName(str): the name of the \"table\" to be used\n            initList(bool): True if the list should be initialized\n            handleInvalidListTypes(bool): True if invalidListTypes should be converted or filtered\n            filterInvalidListTypes(bool): True if invalidListTypes should be deleted\n        \"\"\"\n        self.clazz = clazz\n        self.handleInvalidListTypes = handleInvalidListTypes\n        self.filterInvalidListTypes = filterInvalidListTypes\n        if listName is None:\n            if self.clazz is not None:\n                listName = self.clazz.getPluralname()\n            else:\n                listName = self.__class__.name.lower()\n        self.listName = listName\n        if tableName is None:\n            self.tableName = listName\n        else:\n            self.tableName = tableName\n        if initList:\n            self.__dict__[self.listName] = []\n\n    def getList(self):\n        \"\"\"Get my list.\"\"\"\n        return self.__dict__[self.listName]\n\n    def setListFromLoD(self, lod: list) -&gt; list:\n        \"\"\"Set my list from the given list of dicts.\n\n        Args:\n            lod(list) a raw record list of dicts\n\n        Returns:\n            list: a list of dicts if no clazz is set\n                otherwise a list of objects\n        \"\"\"\n        # non OO mode\n        if self.clazz is None:\n            result = lod\n            self.__dict__[self.listName] = result\n        else:\n            # ORM mode\n            # TODO - handle errors\n            self.fromLoD(lod, append=False)\n        return self.getList()\n\n    def getLoDfromJson(self, jsonStr: str, types=None, listName: str = None):\n        \"\"\"Get a list of Dicts form the given JSON String.\n\n        Args:\n            jsonStr(str): the JSON string\n            fixType(Types): the types to be fixed\n        Returns:\n            list: a list of dicts\n        \"\"\"\n        # read a data structe from the given JSON string\n        lodOrDict = json.loads(jsonStr)\n        # it should be a list only of dict with my list\n        if not isinstance(lodOrDict, dict) and listName is not None:\n            lod = lodOrDict\n        else:\n            if self.listName in lodOrDict:\n                # get the relevant list of dicts\n                lod = lodOrDict[self.listName]\n            else:\n                msg = f\"invalid JSON for getLoD from Json\\nexpecting a list of dicts or a dict with '{self.listName}' as list\\nfound a dict with keys: {lodOrDict.keys()} instead\"\n                raise Exception(msg)\n        if types is not None:\n            types.fixTypes(lod, self.listName)\n        return lod\n\n    def fromLoD(self, lod, append: bool = True, debug: bool = False):\n        \"\"\"Load my entityList from the given list of dicts.\n\n        Args:\n            lod(list): the list of dicts to load\n            append(bool): if True append to my existing entries\n\n        Return:\n            list: a list of errors (if any)\n        \"\"\"\n        errors = []\n        entityList = self.getList()\n        if not append:\n            del entityList[:]\n        if self.handleInvalidListTypes:\n            LOD.handleListTypes(lod=lod, doFilter=self.filterInvalidListTypes)\n\n        for record in lod:\n            # call the constructor to get a new instance\n            try:\n                entity = self.clazz()\n                entity.fromDict(record)\n                entityList.append(entity)\n            except Exception as ex:\n                error = {self.listName: record, \"error\": ex}\n                errors.append(error)\n                if debug:\n                    print(error)\n        return errors\n\n    def getLookup(self, attrName: str, withDuplicates: bool = False):\n        \"\"\"Create a lookup dictionary by the given attribute name.\n\n        Args:\n            attrName(str): the attribute to lookup\n            withDuplicates(bool): whether to retain single values or lists\n\n        Return:\n            a dictionary for lookup or a tuple dictionary,list of duplicates depending on withDuplicates\n        \"\"\"\n        return LOD.getLookup(self.getList(), attrName, withDuplicates)\n\n    def getJsonData(self):\n        \"\"\"Get my Jsondata.\"\"\"\n        jsonData = {self.listName: self.__dict__[self.listName]}\n        return jsonData\n\n    def toJsonAbleValue(self, v):\n        \"\"\"Make sure we don't store our meta information clazz, tableName and\n        listName but just the list we are holding.\"\"\"\n        if v == self:\n            return self.getJsonData()\n        else:\n            return super().toJsonAbleValue(v)\n\n    def fromJson(self, jsonStr, types=None):\n        \"\"\"Initialize me from the given JSON string.\n\n        Args:\n            jsonStr(str): the JSON string\n            fixType(Types): the types to be fixed\n        \"\"\"\n        lod = self.getLoDfromJson(jsonStr, types, listName=self.listName)\n        self.setListFromLoD(lod)\n\n    def asJSON(self, asString=True):\n        jsonData = self.getJsonData()\n        return super().asJSON(asString, data=jsonData)\n\n    def restoreFromJsonFile(self, jsonFile: str) -&gt; list:\n        \"\"\"Read my list of dicts and restore it.\"\"\"\n        lod = self.readLodFromJsonFile(jsonFile)\n        return self.setListFromLoD(lod)\n\n    def restoreFromJsonStr(self, jsonStr: str) -&gt; list:\n        \"\"\"Restore me from the given jsonStr.\n\n        Args:\n            jsonStr(str): the json string to restore me from\n        \"\"\"\n        lod = self.readLodFromJsonStr(jsonStr)\n        return self.setListFromLoD(lod)\n\n    def readLodFromJsonFile(self, jsonFile: str, extension: str = \".json\"):\n        \"\"\"Read the list of dicts from the given jsonFile.\n\n        Args:\n            jsonFile(string): the jsonFile to read from\n\n        Returns:\n            list: a list of dicts\n        \"\"\"\n        jsonFile = self.checkExtension(jsonFile, extension)\n        jsonStr = JSONAble.readJsonFromFile(jsonFile)\n        lod = self.readLodFromJsonStr(jsonStr)\n        return lod\n\n    def readLodFromJsonStr(self, jsonStr) -&gt; list:\n        \"\"\"Restore me from the given jsonStr.\n\n        Args:\n            storeFilePrefix(string): the prefix for the JSON file name\n        \"\"\"\n        if self.clazz is None:\n            typeSamples = self.getJsonTypeSamples()\n        else:\n            typeSamples = self.clazz.getSamples()\n        if typeSamples is None:\n            types = None\n        else:\n            types = Types(\n                self.listName, warnOnUnsupportedTypes=not self.handleInvalidListTypes\n            )\n            types.getTypes(self.listName, typeSamples, len(typeSamples))\n        lod = self.getLoDfromJson(jsonStr, types, listName=self.listName)\n        return lod\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList.__init__","title":"<code>__init__(listName=None, clazz=None, tableName=None, initList=True, handleInvalidListTypes=False, filterInvalidListTypes=False)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>listName(str)</code> <p>the name of the list attribute to be used for storing the List</p> required <code>clazz(class)</code> <p>a class to be used for Object relational mapping (if any)</p> required <code>tableName(str)</code> <p>the name of the \"table\" to be used</p> required <code>initList(bool)</code> <p>True if the list should be initialized</p> required <code>handleInvalidListTypes(bool)</code> <p>True if invalidListTypes should be converted or filtered</p> required <code>filterInvalidListTypes(bool)</code> <p>True if invalidListTypes should be deleted</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def __init__(\n    self,\n    listName: str = None,\n    clazz=None,\n    tableName: str = None,\n    initList: bool = True,\n    handleInvalidListTypes=False,\n    filterInvalidListTypes=False,\n):\n    \"\"\"Constructor.\n\n    Args:\n        listName(str): the name of the list attribute to be used for storing the List\n        clazz(class): a class to be used for Object relational mapping (if any)\n        tableName(str): the name of the \"table\" to be used\n        initList(bool): True if the list should be initialized\n        handleInvalidListTypes(bool): True if invalidListTypes should be converted or filtered\n        filterInvalidListTypes(bool): True if invalidListTypes should be deleted\n    \"\"\"\n    self.clazz = clazz\n    self.handleInvalidListTypes = handleInvalidListTypes\n    self.filterInvalidListTypes = filterInvalidListTypes\n    if listName is None:\n        if self.clazz is not None:\n            listName = self.clazz.getPluralname()\n        else:\n            listName = self.__class__.name.lower()\n    self.listName = listName\n    if tableName is None:\n        self.tableName = listName\n    else:\n        self.tableName = tableName\n    if initList:\n        self.__dict__[self.listName] = []\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList.fromJson","title":"<code>fromJson(jsonStr, types=None)</code>","text":"<p>Initialize me from the given JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>jsonStr(str)</code> <p>the JSON string</p> required <code>fixType(Types)</code> <p>the types to be fixed</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def fromJson(self, jsonStr, types=None):\n    \"\"\"Initialize me from the given JSON string.\n\n    Args:\n        jsonStr(str): the JSON string\n        fixType(Types): the types to be fixed\n    \"\"\"\n    lod = self.getLoDfromJson(jsonStr, types, listName=self.listName)\n    self.setListFromLoD(lod)\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList.fromLoD","title":"<code>fromLoD(lod, append=True, debug=False)</code>","text":"<p>Load my entityList from the given list of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>the list of dicts to load</p> required <code>append(bool)</code> <p>if True append to my existing entries</p> required Return <p>list: a list of errors (if any)</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def fromLoD(self, lod, append: bool = True, debug: bool = False):\n    \"\"\"Load my entityList from the given list of dicts.\n\n    Args:\n        lod(list): the list of dicts to load\n        append(bool): if True append to my existing entries\n\n    Return:\n        list: a list of errors (if any)\n    \"\"\"\n    errors = []\n    entityList = self.getList()\n    if not append:\n        del entityList[:]\n    if self.handleInvalidListTypes:\n        LOD.handleListTypes(lod=lod, doFilter=self.filterInvalidListTypes)\n\n    for record in lod:\n        # call the constructor to get a new instance\n        try:\n            entity = self.clazz()\n            entity.fromDict(record)\n            entityList.append(entity)\n        except Exception as ex:\n            error = {self.listName: record, \"error\": ex}\n            errors.append(error)\n            if debug:\n                print(error)\n    return errors\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList.getJsonData","title":"<code>getJsonData()</code>","text":"<p>Get my Jsondata.</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def getJsonData(self):\n    \"\"\"Get my Jsondata.\"\"\"\n    jsonData = {self.listName: self.__dict__[self.listName]}\n    return jsonData\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList.getList","title":"<code>getList()</code>","text":"<p>Get my list.</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def getList(self):\n    \"\"\"Get my list.\"\"\"\n    return self.__dict__[self.listName]\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList.getLoDfromJson","title":"<code>getLoDfromJson(jsonStr, types=None, listName=None)</code>","text":"<p>Get a list of Dicts form the given JSON String.</p> <p>Parameters:</p> Name Type Description Default <code>jsonStr(str)</code> <p>the JSON string</p> required <code>fixType(Types)</code> <p>the types to be fixed</p> required <p>Returns:     list: a list of dicts</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def getLoDfromJson(self, jsonStr: str, types=None, listName: str = None):\n    \"\"\"Get a list of Dicts form the given JSON String.\n\n    Args:\n        jsonStr(str): the JSON string\n        fixType(Types): the types to be fixed\n    Returns:\n        list: a list of dicts\n    \"\"\"\n    # read a data structe from the given JSON string\n    lodOrDict = json.loads(jsonStr)\n    # it should be a list only of dict with my list\n    if not isinstance(lodOrDict, dict) and listName is not None:\n        lod = lodOrDict\n    else:\n        if self.listName in lodOrDict:\n            # get the relevant list of dicts\n            lod = lodOrDict[self.listName]\n        else:\n            msg = f\"invalid JSON for getLoD from Json\\nexpecting a list of dicts or a dict with '{self.listName}' as list\\nfound a dict with keys: {lodOrDict.keys()} instead\"\n            raise Exception(msg)\n    if types is not None:\n        types.fixTypes(lod, self.listName)\n    return lod\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList.getLookup","title":"<code>getLookup(attrName, withDuplicates=False)</code>","text":"<p>Create a lookup dictionary by the given attribute name.</p> <p>Parameters:</p> Name Type Description Default <code>attrName(str)</code> <p>the attribute to lookup</p> required <code>withDuplicates(bool)</code> <p>whether to retain single values or lists</p> required Return <p>a dictionary for lookup or a tuple dictionary,list of duplicates depending on withDuplicates</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def getLookup(self, attrName: str, withDuplicates: bool = False):\n    \"\"\"Create a lookup dictionary by the given attribute name.\n\n    Args:\n        attrName(str): the attribute to lookup\n        withDuplicates(bool): whether to retain single values or lists\n\n    Return:\n        a dictionary for lookup or a tuple dictionary,list of duplicates depending on withDuplicates\n    \"\"\"\n    return LOD.getLookup(self.getList(), attrName, withDuplicates)\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList.readLodFromJsonFile","title":"<code>readLodFromJsonFile(jsonFile, extension='.json')</code>","text":"<p>Read the list of dicts from the given jsonFile.</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile(string)</code> <p>the jsonFile to read from</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>a list of dicts</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def readLodFromJsonFile(self, jsonFile: str, extension: str = \".json\"):\n    \"\"\"Read the list of dicts from the given jsonFile.\n\n    Args:\n        jsonFile(string): the jsonFile to read from\n\n    Returns:\n        list: a list of dicts\n    \"\"\"\n    jsonFile = self.checkExtension(jsonFile, extension)\n    jsonStr = JSONAble.readJsonFromFile(jsonFile)\n    lod = self.readLodFromJsonStr(jsonStr)\n    return lod\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList.readLodFromJsonStr","title":"<code>readLodFromJsonStr(jsonStr)</code>","text":"<p>Restore me from the given jsonStr.</p> <p>Parameters:</p> Name Type Description Default <code>storeFilePrefix(string)</code> <p>the prefix for the JSON file name</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def readLodFromJsonStr(self, jsonStr) -&gt; list:\n    \"\"\"Restore me from the given jsonStr.\n\n    Args:\n        storeFilePrefix(string): the prefix for the JSON file name\n    \"\"\"\n    if self.clazz is None:\n        typeSamples = self.getJsonTypeSamples()\n    else:\n        typeSamples = self.clazz.getSamples()\n    if typeSamples is None:\n        types = None\n    else:\n        types = Types(\n            self.listName, warnOnUnsupportedTypes=not self.handleInvalidListTypes\n        )\n        types.getTypes(self.listName, typeSamples, len(typeSamples))\n    lod = self.getLoDfromJson(jsonStr, types, listName=self.listName)\n    return lod\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList.restoreFromJsonFile","title":"<code>restoreFromJsonFile(jsonFile)</code>","text":"<p>Read my list of dicts and restore it.</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def restoreFromJsonFile(self, jsonFile: str) -&gt; list:\n    \"\"\"Read my list of dicts and restore it.\"\"\"\n    lod = self.readLodFromJsonFile(jsonFile)\n    return self.setListFromLoD(lod)\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList.restoreFromJsonStr","title":"<code>restoreFromJsonStr(jsonStr)</code>","text":"<p>Restore me from the given jsonStr.</p> <p>Parameters:</p> Name Type Description Default <code>jsonStr(str)</code> <p>the json string to restore me from</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def restoreFromJsonStr(self, jsonStr: str) -&gt; list:\n    \"\"\"Restore me from the given jsonStr.\n\n    Args:\n        jsonStr(str): the json string to restore me from\n    \"\"\"\n    lod = self.readLodFromJsonStr(jsonStr)\n    return self.setListFromLoD(lod)\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList.setListFromLoD","title":"<code>setListFromLoD(lod)</code>","text":"<p>Set my list from the given list of dicts.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>a list of dicts if no clazz is set otherwise a list of objects</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def setListFromLoD(self, lod: list) -&gt; list:\n    \"\"\"Set my list from the given list of dicts.\n\n    Args:\n        lod(list) a raw record list of dicts\n\n    Returns:\n        list: a list of dicts if no clazz is set\n            otherwise a list of objects\n    \"\"\"\n    # non OO mode\n    if self.clazz is None:\n        result = lod\n        self.__dict__[self.listName] = result\n    else:\n        # ORM mode\n        # TODO - handle errors\n        self.fromLoD(lod, append=False)\n    return self.getList()\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleList.toJsonAbleValue","title":"<code>toJsonAbleValue(v)</code>","text":"<p>Make sure we don't store our meta information clazz, tableName and listName but just the list we are holding.</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def toJsonAbleValue(self, v):\n    \"\"\"Make sure we don't store our meta information clazz, tableName and\n    listName but just the list we are holding.\"\"\"\n    if v == self:\n        return self.getJsonData()\n    else:\n        return super().toJsonAbleValue(v)\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleSettings","title":"<code>JSONAbleSettings</code>","text":"<p>settings for JSONAble - put in a separate class so they would not be serialized</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>class JSONAbleSettings:\n    \"\"\"\n    settings for JSONAble - put in a separate class so they would not be\n    serialized\n    \"\"\"\n\n    indent = 4\n    \"\"\"\n    regular expression to be used for conversion from singleQuote to doubleQuote\n    see https://stackoverflow.com/a/50257217/1497139\n    \"\"\"\n    singleQuoteRegex = re.compile(\"(?&lt;!\\\\\\\\)'\")\n</code></pre>"},{"location":"#lodentity.jsonable.JSONAbleSettings.indent","title":"<code>indent = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>regular expression to be used for conversion from singleQuote to doubleQuote see https://stackoverflow.com/a/50257217/1497139</p>"},{"location":"#lodentity.jsonable.Types","title":"<code>Types</code>","text":"<p>               Bases: <code>JSONAble</code></p> <p>Types.</p> <p>holds entity meta Info</p> <p>:ivar name(string): entity name = table name</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>class Types(JSONAble):\n    \"\"\"Types.\n\n    holds entity meta Info\n\n    :ivar name(string): entity name = table name\n    \"\"\"\n\n    typeName2Type = {\n        \"bool\": bool,\n        \"date\": datetime.date,\n        \"datetime\": datetime.datetime,\n        \"float\": float,\n        \"int\": int,\n        \"str\": str,\n    }\n\n    def __init__(self, name: str, warnOnUnsupportedTypes=True, debug=False):\n        \"\"\"Constructor.\n\n        Args:\n            name(str): the name of the type map\n            warnOnUnsupportedTypes(bool): if TRUE warn if an item value has an unsupported type\n            debug(bool): if True - debugging information should be shown\n        \"\"\"\n        self.name = name\n        self.warnOnUnsupportedTypes = warnOnUnsupportedTypes\n        self.debug = debug\n        self.typeMap = {}\n\n    @staticmethod\n    def forTable(\n        instance, listName: str, warnOnUnsupportedTypes: bool = True, debug=False\n    ):\n        \"\"\"\n        get the types for the list of Dicts (table) in the given instance with the given listName\n        Args:\n            instance(object): the instance to inspect\n            listName(string): the list of dicts to inspect\n            warnOnUnsupportedTypes(bool): if TRUE warn if an item value has an unsupported type\n            debug(bool): True if debuggin information should be shown\n\n        Returns:\n            Types: a types object\n        \"\"\"\n        clazz = type(instance)\n        types = Types(\n            clazz.__name__, warnOnUnsupportedTypes=warnOnUnsupportedTypes, debug=debug\n        )\n        types.getTypes(listName, instance.__dict__[listName])\n        return types\n\n    def addType(self, listName, field, valueType):\n        \"\"\"Add the python type for the given field to the typeMap.\n\n        Args:\n           listName(string): the name of the list of the field\n           field(string): the name of the field\n\n           valueType(type): the python type of the field\n        \"\"\"\n        if listName not in self.typeMap:\n            self.typeMap[listName] = {}\n        typeMap = self.typeMap[listName]\n        if not field in typeMap:\n            typeMap[field] = valueType\n\n    def getTypes(self, listName: str, sampleRecords: list, limit: int = 10):\n        \"\"\"Determine the types for the given sample records.\n\n        Args:\n            listName(str): the name of the list\n            sampleRecords(list): a list of items\n            limit(int): the maximum number of items to check\n        \"\"\"\n        for sampleRecord in sampleRecords[:limit]:\n            items = sampleRecord.items()\n            self.getTypesForItems(listName, items, warnOnNone=len(sampleRecords) == 1)\n\n    def getTypesForItems(self, listName: str, items: list, warnOnNone: bool = False):\n        \"\"\"Get the types for the given items side effect is setting my types.\n\n        Args:\n            listName(str): the name of the list\n            items(list): a list of items\n            warnOnNone(bool): if TRUE warn if an item value is None\n        \"\"\"\n        for key, value in items:\n            valueType = None\n            if value is None:\n                if warnOnNone and self.debug:\n                    print(\n                        f\"Warning sampleRecord field {key} is None - using string as type\"\n                    )\n                    valueType = str\n            else:\n                valueType = type(value)\n            if valueType == str:\n                pass\n            elif valueType == int:\n                pass\n            elif valueType == float:\n                pass\n            elif valueType == bool:\n                pass\n            elif valueType == datetime.date:\n                pass\n            elif valueType == datetime.datetime:\n                pass\n            else:\n                if valueType is not None:\n                    msg = f\"warning: unsupported type {str(valueType)} for field {key}\"\n                    if self.debug and self.warnOnUnsupportedTypes:\n                        print(msg)\n            if valueType is not None:\n                self.addType(listName, key, valueType.__name__)\n\n    def fixTypes(self, lod: list, listName: str):\n        \"\"\"Fix the types in the given data structure.\n\n        Args:\n            lod(list): a list of dicts\n            listName(str): the types to lookup by list name\n        \"\"\"\n        for listName in self.typeMap:\n            self.fixListOfDicts(self.typeMap[listName], lod)\n\n    def getType(self, typeName):\n        \"\"\"Get the type for the given type name.\"\"\"\n        if typeName in Types.typeName2Type:\n            return Types.typeName2Type[typeName]\n        else:\n            if self.debug:\n                print(\"Warning unsupported type %s\" % typeName)\n            return None\n\n    def fixListOfDicts(self, typeMap, listOfDicts):\n        \"\"\"Fix the type in the given list of Dicts.\"\"\"\n        for record in listOfDicts:\n            for keyValue in record.items():\n                key, value = keyValue\n                if value is None:\n                    record[key] = None\n                elif key in typeMap:\n                    valueType = self.getType(typeMap[key])\n                    if valueType == bool:\n                        if type(value) == str:\n                            b = value in [\"True\", \"TRUE\", \"true\"]\n                        else:\n                            b = value\n                        record[key] = b\n                    elif valueType == datetime.date:\n                        dt = datetime.datetime.strptime(value, \"%Y-%m-%d\")\n                        record[key] = dt.date()\n                    elif valueType == datetime.datetime:\n                        # see https://stackoverflow.com/questions/127803/how-do-i-parse-an-iso-8601-formatted-date\n                        if isinstance(value, str):\n                            if sys.version_info &gt;= (3, 7):\n                                dtime = datetime.datetime.fromisoformat(value)\n                            else:\n                                dtime = datetime.datetime.strptime(\n                                    value, \"%Y-%m-%dT%H:%M:%S.%f\"\n                                )\n                        else:\n                            # TODO: error handling\n                            dtime = None\n                        record[key] = dtime\n</code></pre>"},{"location":"#lodentity.jsonable.Types.__init__","title":"<code>__init__(name, warnOnUnsupportedTypes=True, debug=False)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>the name of the type map</p> required <code>warnOnUnsupportedTypes(bool)</code> <p>if TRUE warn if an item value has an unsupported type</p> required <code>debug(bool)</code> <p>if True - debugging information should be shown</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def __init__(self, name: str, warnOnUnsupportedTypes=True, debug=False):\n    \"\"\"Constructor.\n\n    Args:\n        name(str): the name of the type map\n        warnOnUnsupportedTypes(bool): if TRUE warn if an item value has an unsupported type\n        debug(bool): if True - debugging information should be shown\n    \"\"\"\n    self.name = name\n    self.warnOnUnsupportedTypes = warnOnUnsupportedTypes\n    self.debug = debug\n    self.typeMap = {}\n</code></pre>"},{"location":"#lodentity.jsonable.Types.addType","title":"<code>addType(listName, field, valueType)</code>","text":"<p>Add the python type for the given field to the typeMap.</p> <p>Parameters:</p> Name Type Description Default <code>listName(string)</code> <p>the name of the list of the field</p> required <code>field(string)</code> <p>the name of the field</p> required <code>valueType(type)</code> <p>the python type of the field</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def addType(self, listName, field, valueType):\n    \"\"\"Add the python type for the given field to the typeMap.\n\n    Args:\n       listName(string): the name of the list of the field\n       field(string): the name of the field\n\n       valueType(type): the python type of the field\n    \"\"\"\n    if listName not in self.typeMap:\n        self.typeMap[listName] = {}\n    typeMap = self.typeMap[listName]\n    if not field in typeMap:\n        typeMap[field] = valueType\n</code></pre>"},{"location":"#lodentity.jsonable.Types.fixListOfDicts","title":"<code>fixListOfDicts(typeMap, listOfDicts)</code>","text":"<p>Fix the type in the given list of Dicts.</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def fixListOfDicts(self, typeMap, listOfDicts):\n    \"\"\"Fix the type in the given list of Dicts.\"\"\"\n    for record in listOfDicts:\n        for keyValue in record.items():\n            key, value = keyValue\n            if value is None:\n                record[key] = None\n            elif key in typeMap:\n                valueType = self.getType(typeMap[key])\n                if valueType == bool:\n                    if type(value) == str:\n                        b = value in [\"True\", \"TRUE\", \"true\"]\n                    else:\n                        b = value\n                    record[key] = b\n                elif valueType == datetime.date:\n                    dt = datetime.datetime.strptime(value, \"%Y-%m-%d\")\n                    record[key] = dt.date()\n                elif valueType == datetime.datetime:\n                    # see https://stackoverflow.com/questions/127803/how-do-i-parse-an-iso-8601-formatted-date\n                    if isinstance(value, str):\n                        if sys.version_info &gt;= (3, 7):\n                            dtime = datetime.datetime.fromisoformat(value)\n                        else:\n                            dtime = datetime.datetime.strptime(\n                                value, \"%Y-%m-%dT%H:%M:%S.%f\"\n                            )\n                    else:\n                        # TODO: error handling\n                        dtime = None\n                    record[key] = dtime\n</code></pre>"},{"location":"#lodentity.jsonable.Types.fixTypes","title":"<code>fixTypes(lod, listName)</code>","text":"<p>Fix the types in the given data structure.</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>a list of dicts</p> required <code>listName(str)</code> <p>the types to lookup by list name</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def fixTypes(self, lod: list, listName: str):\n    \"\"\"Fix the types in the given data structure.\n\n    Args:\n        lod(list): a list of dicts\n        listName(str): the types to lookup by list name\n    \"\"\"\n    for listName in self.typeMap:\n        self.fixListOfDicts(self.typeMap[listName], lod)\n</code></pre>"},{"location":"#lodentity.jsonable.Types.forTable","title":"<code>forTable(instance, listName, warnOnUnsupportedTypes=True, debug=False)</code>  <code>staticmethod</code>","text":"<p>get the types for the list of Dicts (table) in the given instance with the given listName Args:     instance(object): the instance to inspect     listName(string): the list of dicts to inspect     warnOnUnsupportedTypes(bool): if TRUE warn if an item value has an unsupported type     debug(bool): True if debuggin information should be shown</p> <p>Returns:</p> Name Type Description <code>Types</code> <p>a types object</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>@staticmethod\ndef forTable(\n    instance, listName: str, warnOnUnsupportedTypes: bool = True, debug=False\n):\n    \"\"\"\n    get the types for the list of Dicts (table) in the given instance with the given listName\n    Args:\n        instance(object): the instance to inspect\n        listName(string): the list of dicts to inspect\n        warnOnUnsupportedTypes(bool): if TRUE warn if an item value has an unsupported type\n        debug(bool): True if debuggin information should be shown\n\n    Returns:\n        Types: a types object\n    \"\"\"\n    clazz = type(instance)\n    types = Types(\n        clazz.__name__, warnOnUnsupportedTypes=warnOnUnsupportedTypes, debug=debug\n    )\n    types.getTypes(listName, instance.__dict__[listName])\n    return types\n</code></pre>"},{"location":"#lodentity.jsonable.Types.getType","title":"<code>getType(typeName)</code>","text":"<p>Get the type for the given type name.</p> Source code in <code>lodentity/jsonable.py</code> <pre><code>def getType(self, typeName):\n    \"\"\"Get the type for the given type name.\"\"\"\n    if typeName in Types.typeName2Type:\n        return Types.typeName2Type[typeName]\n    else:\n        if self.debug:\n            print(\"Warning unsupported type %s\" % typeName)\n        return None\n</code></pre>"},{"location":"#lodentity.jsonable.Types.getTypes","title":"<code>getTypes(listName, sampleRecords, limit=10)</code>","text":"<p>Determine the types for the given sample records.</p> <p>Parameters:</p> Name Type Description Default <code>listName(str)</code> <p>the name of the list</p> required <code>sampleRecords(list)</code> <p>a list of items</p> required <code>limit(int)</code> <p>the maximum number of items to check</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def getTypes(self, listName: str, sampleRecords: list, limit: int = 10):\n    \"\"\"Determine the types for the given sample records.\n\n    Args:\n        listName(str): the name of the list\n        sampleRecords(list): a list of items\n        limit(int): the maximum number of items to check\n    \"\"\"\n    for sampleRecord in sampleRecords[:limit]:\n        items = sampleRecord.items()\n        self.getTypesForItems(listName, items, warnOnNone=len(sampleRecords) == 1)\n</code></pre>"},{"location":"#lodentity.jsonable.Types.getTypesForItems","title":"<code>getTypesForItems(listName, items, warnOnNone=False)</code>","text":"<p>Get the types for the given items side effect is setting my types.</p> <p>Parameters:</p> Name Type Description Default <code>listName(str)</code> <p>the name of the list</p> required <code>items(list)</code> <p>a list of items</p> required <code>warnOnNone(bool)</code> <p>if TRUE warn if an item value is None</p> required Source code in <code>lodentity/jsonable.py</code> <pre><code>def getTypesForItems(self, listName: str, items: list, warnOnNone: bool = False):\n    \"\"\"Get the types for the given items side effect is setting my types.\n\n    Args:\n        listName(str): the name of the list\n        items(list): a list of items\n        warnOnNone(bool): if TRUE warn if an item value is None\n    \"\"\"\n    for key, value in items:\n        valueType = None\n        if value is None:\n            if warnOnNone and self.debug:\n                print(\n                    f\"Warning sampleRecord field {key} is None - using string as type\"\n                )\n                valueType = str\n        else:\n            valueType = type(value)\n        if valueType == str:\n            pass\n        elif valueType == int:\n            pass\n        elif valueType == float:\n            pass\n        elif valueType == bool:\n            pass\n        elif valueType == datetime.date:\n            pass\n        elif valueType == datetime.datetime:\n            pass\n        else:\n            if valueType is not None:\n                msg = f\"warning: unsupported type {str(valueType)} for field {key}\"\n                if self.debug and self.warnOnUnsupportedTypes:\n                    print(msg)\n        if valueType is not None:\n            self.addType(listName, key, valueType.__name__)\n</code></pre>"},{"location":"#lodentity.jsonpicklemixin","title":"<code>jsonpicklemixin</code>","text":""},{"location":"#lodentity.jsonpicklemixin.JsonPickleMixin","title":"<code>JsonPickleMixin</code>","text":"<p>               Bases: <code>object</code></p> <p>Allow reading and writing derived objects from a jsonpickle file.</p> Source code in <code>lodentity/jsonpicklemixin.py</code> <pre><code>class JsonPickleMixin(object):\n    \"\"\"Allow reading and writing derived objects from a jsonpickle file.\"\"\"\n\n    debug = False\n\n    @staticmethod\n    def checkExtension(jsonFile: str, extension: str = \".json\") -&gt; str:\n        \"\"\"Make sure the jsonFile has the given extension e.g. \".json\".\n\n        Args:\n            jsonFile(str): the jsonFile name - potentially without \".json\" suffix\n\n        Returns:\n            str: the jsonFile name with \".json\" as an extension guaranteed\n        \"\"\"\n        if not jsonFile.endswith(extension):\n            jsonFile = f\"{jsonFile}{extension}\"\n        return jsonFile\n\n    # read me from a json pickle file\n    @staticmethod\n    def readJsonPickle(jsonFileName, extension=\".jsonpickle\"):\n        \"\"\"\n        Args:\n            jsonFileName(str): name of the file (optionally without \".json\" postfix)\n            extension(str): default file extension\n        \"\"\"\n        jsonFileName = JsonPickleMixin.checkExtension(jsonFileName, extension)\n        # is there a jsonFile for the given name\n        if os.path.isfile(jsonFileName):\n            if JsonPickleMixin.debug:\n                print(\"reading %s\" % (jsonFileName))\n            with open(jsonFileName) as jsonFile:\n                json = jsonFile.read()\n            result = jsonpickle.decode(json)\n            if JsonPickleMixin.debug:\n                print(json)\n                print(result)\n            return result\n        else:\n            return None\n\n    def asJsonPickle(self) -&gt; str:\n        \"\"\"Convert me to JSON.\n\n        Returns:\n            str: a JSON String with my JSON representation\n        \"\"\"\n        json = jsonpickle.encode(self)\n        return json\n\n    def writeJsonPickle(self, jsonFileName: str, extension: str = \".jsonpickle\"):\n        \"\"\"Write me to the json file with the given name (optionally without\n        postfix)\n\n        Args:\n            jsonFileName(str): name of the file (optionally without \".json\" postfix)\n            extension(str): default file extension\n        \"\"\"\n        jsonFileName = JsonPickleMixin.checkExtension(jsonFileName, extension)\n        json = self.asJsonPickle()\n        if JsonPickleMixin.debug:\n            print(\"writing %s\" % (jsonFileName))\n            print(json)\n            print(self)\n        jsonFile = open(jsonFileName, \"w\")\n        jsonFile.write(json)\n        jsonFile.close()\n</code></pre>"},{"location":"#lodentity.jsonpicklemixin.JsonPickleMixin.asJsonPickle","title":"<code>asJsonPickle()</code>","text":"<p>Convert me to JSON.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>a JSON String with my JSON representation</p> Source code in <code>lodentity/jsonpicklemixin.py</code> <pre><code>def asJsonPickle(self) -&gt; str:\n    \"\"\"Convert me to JSON.\n\n    Returns:\n        str: a JSON String with my JSON representation\n    \"\"\"\n    json = jsonpickle.encode(self)\n    return json\n</code></pre>"},{"location":"#lodentity.jsonpicklemixin.JsonPickleMixin.checkExtension","title":"<code>checkExtension(jsonFile, extension='.json')</code>  <code>staticmethod</code>","text":"<p>Make sure the jsonFile has the given extension e.g. \".json\".</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile(str)</code> <p>the jsonFile name - potentially without \".json\" suffix</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the jsonFile name with \".json\" as an extension guaranteed</p> Source code in <code>lodentity/jsonpicklemixin.py</code> <pre><code>@staticmethod\ndef checkExtension(jsonFile: str, extension: str = \".json\") -&gt; str:\n    \"\"\"Make sure the jsonFile has the given extension e.g. \".json\".\n\n    Args:\n        jsonFile(str): the jsonFile name - potentially without \".json\" suffix\n\n    Returns:\n        str: the jsonFile name with \".json\" as an extension guaranteed\n    \"\"\"\n    if not jsonFile.endswith(extension):\n        jsonFile = f\"{jsonFile}{extension}\"\n    return jsonFile\n</code></pre>"},{"location":"#lodentity.jsonpicklemixin.JsonPickleMixin.readJsonPickle","title":"<code>readJsonPickle(jsonFileName, extension='.jsonpickle')</code>  <code>staticmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>jsonFileName(str)</code> <p>name of the file (optionally without \".json\" postfix)</p> required <code>extension(str)</code> <p>default file extension</p> required Source code in <code>lodentity/jsonpicklemixin.py</code> <pre><code>@staticmethod\ndef readJsonPickle(jsonFileName, extension=\".jsonpickle\"):\n    \"\"\"\n    Args:\n        jsonFileName(str): name of the file (optionally without \".json\" postfix)\n        extension(str): default file extension\n    \"\"\"\n    jsonFileName = JsonPickleMixin.checkExtension(jsonFileName, extension)\n    # is there a jsonFile for the given name\n    if os.path.isfile(jsonFileName):\n        if JsonPickleMixin.debug:\n            print(\"reading %s\" % (jsonFileName))\n        with open(jsonFileName) as jsonFile:\n            json = jsonFile.read()\n        result = jsonpickle.decode(json)\n        if JsonPickleMixin.debug:\n            print(json)\n            print(result)\n        return result\n    else:\n        return None\n</code></pre>"},{"location":"#lodentity.jsonpicklemixin.JsonPickleMixin.writeJsonPickle","title":"<code>writeJsonPickle(jsonFileName, extension='.jsonpickle')</code>","text":"<p>Write me to the json file with the given name (optionally without postfix)</p> <p>Parameters:</p> Name Type Description Default <code>jsonFileName(str)</code> <p>name of the file (optionally without \".json\" postfix)</p> required <code>extension(str)</code> <p>default file extension</p> required Source code in <code>lodentity/jsonpicklemixin.py</code> <pre><code>def writeJsonPickle(self, jsonFileName: str, extension: str = \".jsonpickle\"):\n    \"\"\"Write me to the json file with the given name (optionally without\n    postfix)\n\n    Args:\n        jsonFileName(str): name of the file (optionally without \".json\" postfix)\n        extension(str): default file extension\n    \"\"\"\n    jsonFileName = JsonPickleMixin.checkExtension(jsonFileName, extension)\n    json = self.asJsonPickle()\n    if JsonPickleMixin.debug:\n        print(\"writing %s\" % (jsonFileName))\n        print(json)\n        print(self)\n    jsonFile = open(jsonFileName, \"w\")\n    jsonFile.write(json)\n    jsonFile.close()\n</code></pre>"}]}